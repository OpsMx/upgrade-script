// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package september2024october2024

import "encoding/json"
import "fmt"
import "reflect"
import "time"

// Title and location where advisory information can be obtained. An advisory is a
// notification of a threat to a component, service, or system.
type Advisory struct {
	// An optional name of the advisory.
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Location where the advisory can be obtained.
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

type AffectedStatus string

const AffectedStatusAffected AffectedStatus = "affected"
const AffectedStatusUnaffected AffectedStatus = "unaffected"
const AffectedStatusUnknown AffectedStatus = "unknown"

type AggregateType string

const AggregateTypeComplete AggregateType = "complete"
const AggregateTypeIncomplete AggregateType = "incomplete"
const AggregateTypeIncompleteFirstPartyOnly AggregateType = "incomplete_first_party_only"
const AggregateTypeIncompleteFirstPartyOpensourceOnly AggregateType = "incomplete_first_party_opensource_only"
const AggregateTypeIncompleteFirstPartyProprietaryOnly AggregateType = "incomplete_first_party_proprietary_only"
const AggregateTypeIncompleteThirdPartyOnly AggregateType = "incomplete_third_party_only"
const AggregateTypeIncompleteThirdPartyOpensourceOnly AggregateType = "incomplete_third_party_opensource_only"
const AggregateTypeIncompleteThirdPartyProprietaryOnly AggregateType = "incomplete_third_party_proprietary_only"
const AggregateTypeNotSpecified AggregateType = "not_specified"
const AggregateTypeUnknown AggregateType = "unknown"

// A comment, note, explanation, or similar textual content which provides
// additional context to the object(s) being annotated.
type Annotations struct {
	// The organization, person, component, or service which created the textual
	// content of the annotation.
	Annotator AnnotationsAnnotator `json:"annotator" yaml:"annotator" mapstructure:"annotator"`

	// An optional identifier which can be used to reference the annotation elsewhere
	// in the BOM. Every bom-ref MUST be unique within the BOM.
	BomRef *RefType `json:"bom-ref,omitempty" yaml:"bom-ref,omitempty" mapstructure:"bom-ref,omitempty"`

	// Enveloped signature in [JSON Signature Format
	// (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
	Signature AnnotationsSignature `json:"signature,omitempty" yaml:"signature,omitempty" mapstructure:"signature,omitempty"`

	// The object in the BOM identified by its bom-ref. This is often a component or
	// service, but may be any object type supporting bom-refs.
	Subjects []interface{} `json:"subjects" yaml:"subjects" mapstructure:"subjects"`

	// The textual content of the annotation.
	Text string `json:"text" yaml:"text" mapstructure:"text"`

	// The date and time (timestamp) when the annotation was created.
	Timestamp time.Time `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`
}

// The organization, person, component, or service which created the textual
// content of the annotation.
type AnnotationsAnnotator struct {
	// The tool or component that created the annotation
	Component *Component `json:"component,omitempty" yaml:"component,omitempty" mapstructure:"component,omitempty"`

	// The person that created the annotation
	Individual *OrganizationalContact `json:"individual,omitempty" yaml:"individual,omitempty" mapstructure:"individual,omitempty"`

	// The organization that created the annotation
	Organization *OrganizationalEntity `json:"organization,omitempty" yaml:"organization,omitempty" mapstructure:"organization,omitempty"`

	// The service that created the annotation
	Service *Service `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`
}

// Enveloped signature in [JSON Signature Format
// (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
type AnnotationsSignature interface{}

// Specifies the metadata and content for an attachment.
type Attachment struct {
	// The attachment data. Proactive controls such as input validation and
	// sanitization should be employed to prevent misuse of attachment text.
	Content string `json:"content" yaml:"content" mapstructure:"content"`

	// Specifies the content type of the text. Defaults to text/plain if not
	// specified.
	ContentType string `json:"contentType,omitempty" yaml:"contentType,omitempty" mapstructure:"contentType,omitempty"`

	// Specifies the optional encoding the text is represented in.
	Encoding *AttachmentEncoding `json:"encoding,omitempty" yaml:"encoding,omitempty" mapstructure:"encoding,omitempty"`
}

type AttachmentEncoding string

const AttachmentEncodingBase64 AttachmentEncoding = "base64"

type BomLink interface{}

// Descriptor for another BOM document. See
// https://cyclonedx.org/capabilities/bomlink/
type BomLinkDocumentType string

// Descriptor for an element in a BOM document. See
// https://cyclonedx.org/capabilities/bomlink/
type BomLinkElementType string

type Command struct {
	// A text representation of the executed command.
	Executed *string `json:"executed,omitempty" yaml:"executed,omitempty" mapstructure:"executed,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

// Specifies an individual commit
type Commit struct {
	// The author who created the changes in the commit
	Author *IdentifiableAction `json:"author,omitempty" yaml:"author,omitempty" mapstructure:"author,omitempty"`

	// The person who committed or pushed the commit
	Committer *IdentifiableAction `json:"committer,omitempty" yaml:"committer,omitempty" mapstructure:"committer,omitempty"`

	// The text description of the contents of the commit
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// A unique identifier of the commit. This may be version control specific. For
	// example, Subversion uses revision numbers whereas git uses commit hashes.
	Uid *string `json:"uid,omitempty" yaml:"uid,omitempty" mapstructure:"uid,omitempty"`

	// The URL to the commit. This URL will typically point to a commit in a version
	// control system.
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

type Component struct {
	// The person(s) or organization(s) that authored the component
	Author *string `json:"author,omitempty" yaml:"author,omitempty" mapstructure:"author,omitempty"`

	// An optional identifier which can be used to reference the component elsewhere
	// in the BOM. Every bom-ref MUST be unique within the BOM.
	BomRef *RefType `json:"bom-ref,omitempty" yaml:"bom-ref,omitempty" mapstructure:"bom-ref,omitempty"`

	// A list of software and hardware components included in the parent component.
	// This is not a dependency tree. It provides a way to specify a hierarchical
	// representation of component assemblies, similar to system &#8594; subsystem
	// &#8594; parts assembly in physical supply chains.
	Components []*Component `json:"components,omitempty" yaml:"components,omitempty" mapstructure:"components,omitempty"`

	// A copyright notice informing users of the underlying claims to copyright
	// ownership in a published work.
	Copyright *string `json:"copyright,omitempty" yaml:"copyright,omitempty" mapstructure:"copyright,omitempty"`

	// Specifies a well-formed CPE name that conforms to the CPE 2.2 or 2.3
	// specification. See
	// [https://nvd.nist.gov/products/cpe](https://nvd.nist.gov/products/cpe)
	Cpe *string `json:"cpe,omitempty" yaml:"cpe,omitempty" mapstructure:"cpe,omitempty"`

	// This object SHOULD be specified for any component of type `data` and MUST NOT
	// be specified for other component types.
	Data []ComponentData `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// Specifies a description for the component
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Provides the ability to document evidence collected through various forms of
	// extraction or analysis.
	Evidence *ComponentEvidence `json:"evidence,omitempty" yaml:"evidence,omitempty" mapstructure:"evidence,omitempty"`

	// External references provide a way to document systems, sites, and information
	// that may be relevant, but are not included with the BOM. They may also
	// establish specific relationships within or external to the BOM.
	ExternalReferences []ExternalReference `json:"externalReferences,omitempty" yaml:"externalReferences,omitempty" mapstructure:"externalReferences,omitempty"`

	// The grouping name or identifier. This will often be a shortened, single name of
	// the company or project that produced the component, or the source package or
	// domain name. Whitespace and special characters should be avoided. Examples
	// include: apache, org.apache.commons, and apache.org.
	Group *string `json:"group,omitempty" yaml:"group,omitempty" mapstructure:"group,omitempty"`

	// Hashes corresponds to the JSON schema field "hashes".
	Hashes []Hash `json:"hashes,omitempty" yaml:"hashes,omitempty" mapstructure:"hashes,omitempty"`

	// Licenses corresponds to the JSON schema field "licenses".
	Licenses LicenseChoice `json:"licenses,omitempty" yaml:"licenses,omitempty" mapstructure:"licenses,omitempty"`

	// The optional mime-type of the component. When used on file components, the
	// mime-type can provide additional context about the kind of file being
	// represented such as an image, font, or executable. Some library or framework
	// components may also have an associated mime-type.
	MimeType *string `json:"mime-type,omitempty" yaml:"mime-type,omitempty" mapstructure:"mime-type,omitempty"`

	// ModelCard corresponds to the JSON schema field "modelCard".
	ModelCard *ModelCard `json:"modelCard,omitempty" yaml:"modelCard,omitempty" mapstructure:"modelCard,omitempty"`

	// [Deprecated] - DO NOT USE. This will be removed in a future version. Use the
	// pedigree element instead to supply information on exactly how the component was
	// modified. A boolean value indicating if the component has been modified from
	// the original. A value of true indicates the component is a derivative of the
	// original. A value of false indicates the component has not been modified from
	// the original.
	Modified *bool `json:"modified,omitempty" yaml:"modified,omitempty" mapstructure:"modified,omitempty"`

	// The name of the component. This will often be a shortened, single name of the
	// component. Examples: commons-lang3 and jquery
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Component pedigree is a way to document complex supply chain scenarios where
	// components are created, distributed, modified, redistributed, combined with
	// other components, etc. Pedigree supports viewing this complex chain from the
	// beginning, the end, or anywhere in the middle. It also provides a way to
	// document variants where the exact relation may not be known.
	Pedigree *ComponentPedigree `json:"pedigree,omitempty" yaml:"pedigree,omitempty" mapstructure:"pedigree,omitempty"`

	// Provides the ability to document properties in a name-value store. This
	// provides flexibility to include data not officially supported in the standard
	// without having to use additional namespaces or create extensions. Unlike
	// key-value stores, properties support duplicate names, each potentially having
	// different values. Property names of interest to the general public are
	// encouraged to be registered in the [CycloneDX Property
	// Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal
	// registration is OPTIONAL.
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The person(s) or organization(s) that published the component
	Publisher *string `json:"publisher,omitempty" yaml:"publisher,omitempty" mapstructure:"publisher,omitempty"`

	// Specifies the package-url (purl). The purl, if specified, MUST be valid and
	// conform to the specification defined at:
	// [https://github.com/package-url/purl-spec](https://github.com/package-url/purl-spec)
	Purl *string `json:"purl,omitempty" yaml:"purl,omitempty" mapstructure:"purl,omitempty"`

	// Specifies optional release notes.
	ReleaseNotes *ReleaseNotes `json:"releaseNotes,omitempty" yaml:"releaseNotes,omitempty" mapstructure:"releaseNotes,omitempty"`

	// Specifies the scope of the component. If scope is not specified, 'required'
	// scope SHOULD be assumed by the consumer of the BOM.
	Scope ComponentScope `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// Enveloped signature in [JSON Signature Format
	// (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
	Signature ComponentSignature `json:"signature,omitempty" yaml:"signature,omitempty" mapstructure:"signature,omitempty"`

	//  The organization that supplied the component. The supplier may often be the
	// manufacturer, but may also be a distributor or repackager.
	Supplier *OrganizationalEntity `json:"supplier,omitempty" yaml:"supplier,omitempty" mapstructure:"supplier,omitempty"`

	// Specifies metadata and content for [ISO-IEC 19770-2 Software Identification
	// (SWID) Tags](https://www.iso.org/standard/65666.html).
	Swid *Swid `json:"swid,omitempty" yaml:"swid,omitempty" mapstructure:"swid,omitempty"`

	// Specifies the type of component. For software components, classify as
	// application if no more specific appropriate classification is available or
	// cannot be determined for the component. Types include:
	//
	// * __application__ = A software application. Refer to
	// [https://en.wikipedia.org/wiki/Application_software](https://en.wikipedia.org/wiki/Application_software)
	// for information about applications.
	// * __framework__ = A software framework. Refer to
	// [https://en.wikipedia.org/wiki/Software_framework](https://en.wikipedia.org/wiki/Software_framework)
	// for information on how frameworks vary slightly from libraries.
	// * __library__ = A software library. Refer to
	// [https://en.wikipedia.org/wiki/Library_(computing)](https://en.wikipedia.org/wiki/Library_(computing))
	//  for information about libraries. All third-party and open source reusable
	// components will likely be a library. If the library also has key features of a
	// framework, then it should be classified as a framework. If not, or is unknown,
	// then specifying library is RECOMMENDED.
	// * __container__ = A packaging and/or runtime format, not specific to any
	// particular technology, which isolates software inside the container from
	// software outside of a container through virtualization technology. Refer to
	// [https://en.wikipedia.org/wiki/OS-level_virtualization](https://en.wikipedia.org/wiki/OS-level_virtualization)
	// * __platform__ = A runtime environment which interprets or executes software.
	// This may include runtimes such as those that execute bytecode or
	// low-code/no-code application platforms.
	// * __operating-system__ = A software operating system without regard to
	// deployment model (i.e. installed on physical hardware, virtual machine, image,
	// etc) Refer to
	// [https://en.wikipedia.org/wiki/Operating_system](https://en.wikipedia.org/wiki/Operating_system)
	// * __device__ = A hardware device such as a processor, or chip-set. A hardware
	// device containing firmware SHOULD include a component for the physical hardware
	// itself, and another component of type 'firmware' or 'operating-system'
	// (whichever is relevant), describing information about the software running on
	// the device.
	//   See also the list of [known device
	// properties](https://github.com/CycloneDX/cyclonedx-property-taxonomy/blob/main/cdx/device.md).
	// * __device-driver__ = A special type of software that operates or controls a
	// particular type of device. Refer to
	// [https://en.wikipedia.org/wiki/Device_driver](https://en.wikipedia.org/wiki/Device_driver)
	// * __firmware__ = A special type of software that provides low-level control
	// over a devices hardware. Refer to
	// [https://en.wikipedia.org/wiki/Firmware](https://en.wikipedia.org/wiki/Firmware)
	// * __file__ = A computer file. Refer to
	// [https://en.wikipedia.org/wiki/Computer_file](https://en.wikipedia.org/wiki/Computer_file)
	// for information about files.
	// * __machine-learning-model__ = A model based on training data that can make
	// predictions or decisions without being explicitly programmed to do so.
	// * __data__ = A collection of discrete values that convey information.
	Type ComponentType `json:"type" yaml:"type" mapstructure:"type"`

	// The component version. The version should ideally comply with semantic
	// versioning but is not enforced.
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type ComponentData struct {
	// An optional identifier which can be used to reference the dataset elsewhere in
	// the BOM. Every bom-ref MUST be unique within the BOM.
	BomRef *RefType `json:"bom-ref,omitempty" yaml:"bom-ref,omitempty" mapstructure:"bom-ref,omitempty"`

	// Classification corresponds to the JSON schema field "classification".
	Classification *DataClassification `json:"classification,omitempty" yaml:"classification,omitempty" mapstructure:"classification,omitempty"`

	// The contents or references to the contents of the data being described.
	Contents *ComponentDataContents `json:"contents,omitempty" yaml:"contents,omitempty" mapstructure:"contents,omitempty"`

	// A description of the dataset. Can describe size of dataset, whether it's used
	// for source code, training, testing, or validation, etc.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Governance corresponds to the JSON schema field "governance".
	Governance *DataGovernance `json:"governance,omitempty" yaml:"governance,omitempty" mapstructure:"governance,omitempty"`

	// Graphics corresponds to the JSON schema field "graphics".
	Graphics *GraphicsCollection `json:"graphics,omitempty" yaml:"graphics,omitempty" mapstructure:"graphics,omitempty"`

	// The name of the dataset.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// A description of any sensitive data in a dataset.
	SensitiveData []string `json:"sensitiveData,omitempty" yaml:"sensitiveData,omitempty" mapstructure:"sensitiveData,omitempty"`

	// The general theme or subject matter of the data being specified.
	//
	// * __source-code__ = Any type of code, code snippet, or data-as-code.
	// * __configuration__ = Parameters or settings that may be used by other
	// components.
	// * __dataset__ = A collection of data.
	// * __definition__ = Data that can be used to create new instances of what the
	// definition defines.
	// * __other__ = Any other type of data that does not fit into existing
	// definitions.
	Type ComponentDataType `json:"type" yaml:"type" mapstructure:"type"`
}

// The contents or references to the contents of the data being described.
type ComponentDataContents struct {
	// An optional way to include textual or encoded data.
	Attachment *Attachment `json:"attachment,omitempty" yaml:"attachment,omitempty" mapstructure:"attachment,omitempty"`

	// Provides the ability to document name-value parameters used for configuration.
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The URL to where the data can be retrieved.
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

type ComponentDataType string

const ComponentDataTypeConfiguration ComponentDataType = "configuration"
const ComponentDataTypeDataset ComponentDataType = "dataset"
const ComponentDataTypeDefinition ComponentDataType = "definition"
const ComponentDataTypeOther ComponentDataType = "other"
const ComponentDataTypeSourceCode ComponentDataType = "source-code"

// Provides the ability to document evidence collected through various forms of
// extraction or analysis.
type ComponentEvidence struct {
	// Evidence of the components use through the callstack.
	Callstack *ComponentEvidenceCallstack `json:"callstack,omitempty" yaml:"callstack,omitempty" mapstructure:"callstack,omitempty"`

	// Copyright corresponds to the JSON schema field "copyright".
	Copyright []Copyright `json:"copyright,omitempty" yaml:"copyright,omitempty" mapstructure:"copyright,omitempty"`

	// Evidence that substantiates the identity of a component.
	Identity *ComponentEvidenceIdentity `json:"identity,omitempty" yaml:"identity,omitempty" mapstructure:"identity,omitempty"`

	// Licenses corresponds to the JSON schema field "licenses".
	Licenses LicenseChoice `json:"licenses,omitempty" yaml:"licenses,omitempty" mapstructure:"licenses,omitempty"`

	// Evidence of individual instances of a component spread across multiple
	// locations.
	Occurrences []ComponentEvidenceOccurrencesElem `json:"occurrences,omitempty" yaml:"occurrences,omitempty" mapstructure:"occurrences,omitempty"`
}

// Evidence of the components use through the callstack.
type ComponentEvidenceCallstack struct {
	// Frames corresponds to the JSON schema field "frames".
	Frames []ComponentEvidenceCallstackFramesElem `json:"frames,omitempty" yaml:"frames,omitempty" mapstructure:"frames,omitempty"`
}

type ComponentEvidenceCallstackFramesElem struct {
	// The column the code that is called resides.
	Column *int `json:"column,omitempty" yaml:"column,omitempty" mapstructure:"column,omitempty"`

	// The full path and filename of the module.
	FullFilename *string `json:"fullFilename,omitempty" yaml:"fullFilename,omitempty" mapstructure:"fullFilename,omitempty"`

	// A block of code designed to perform a particular task.
	Function *string `json:"function,omitempty" yaml:"function,omitempty" mapstructure:"function,omitempty"`

	// The line number the code that is called resides on.
	Line *int `json:"line,omitempty" yaml:"line,omitempty" mapstructure:"line,omitempty"`

	// A module or class that encloses functions/methods and other code.
	Module string `json:"module" yaml:"module" mapstructure:"module"`

	// A package organizes modules into namespaces, providing a unique namespace for
	// each type it contains.
	Package *string `json:"package,omitempty" yaml:"package,omitempty" mapstructure:"package,omitempty"`

	// Optional arguments that are passed to the module or function.
	Parameters []string `json:"parameters,omitempty" yaml:"parameters,omitempty" mapstructure:"parameters,omitempty"`
}

// Evidence that substantiates the identity of a component.
type ComponentEvidenceIdentity struct {
	// The overall confidence of the evidence from 0 - 1, where 1 is 100% confidence.
	Confidence *float64 `json:"confidence,omitempty" yaml:"confidence,omitempty" mapstructure:"confidence,omitempty"`

	// The identity field of the component which the evidence describes.
	Field ComponentEvidenceIdentityField `json:"field" yaml:"field" mapstructure:"field"`

	// The methods used to extract and/or analyze the evidence.
	Methods []ComponentEvidenceIdentityMethodsElem `json:"methods,omitempty" yaml:"methods,omitempty" mapstructure:"methods,omitempty"`

	// The object in the BOM identified by its bom-ref. This is often a component or
	// service, but may be any object type supporting bom-refs. Tools used for
	// analysis should already be defined in the BOM, either in the metadata/tools,
	// components, or formulation.
	Tools []interface{} `json:"tools,omitempty" yaml:"tools,omitempty" mapstructure:"tools,omitempty"`
}

type ComponentEvidenceIdentityField string

const ComponentEvidenceIdentityFieldCpe ComponentEvidenceIdentityField = "cpe"
const ComponentEvidenceIdentityFieldGroup ComponentEvidenceIdentityField = "group"
const ComponentEvidenceIdentityFieldHash ComponentEvidenceIdentityField = "hash"
const ComponentEvidenceIdentityFieldName ComponentEvidenceIdentityField = "name"
const ComponentEvidenceIdentityFieldPurl ComponentEvidenceIdentityField = "purl"
const ComponentEvidenceIdentityFieldSwid ComponentEvidenceIdentityField = "swid"
const ComponentEvidenceIdentityFieldVersion ComponentEvidenceIdentityField = "version"

type ComponentEvidenceIdentityMethodsElem struct {
	// The confidence of the evidence from 0 - 1, where 1 is 100% confidence.
	// Confidence is specific to the technique used. Each technique of analysis can
	// have independent confidence.
	Confidence float64 `json:"confidence" yaml:"confidence" mapstructure:"confidence"`

	// The technique used in this method of analysis.
	Technique ComponentEvidenceIdentityMethodsElemTechnique `json:"technique" yaml:"technique" mapstructure:"technique"`

	// The value or contents of the evidence.
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

type ComponentEvidenceIdentityMethodsElemTechnique string

const ComponentEvidenceIdentityMethodsElemTechniqueAstFingerprint ComponentEvidenceIdentityMethodsElemTechnique = "ast-fingerprint"
const ComponentEvidenceIdentityMethodsElemTechniqueAttestation ComponentEvidenceIdentityMethodsElemTechnique = "attestation"
const ComponentEvidenceIdentityMethodsElemTechniqueBinaryAnalysis ComponentEvidenceIdentityMethodsElemTechnique = "binary-analysis"
const ComponentEvidenceIdentityMethodsElemTechniqueDynamicAnalysis ComponentEvidenceIdentityMethodsElemTechnique = "dynamic-analysis"
const ComponentEvidenceIdentityMethodsElemTechniqueFilename ComponentEvidenceIdentityMethodsElemTechnique = "filename"
const ComponentEvidenceIdentityMethodsElemTechniqueHashComparison ComponentEvidenceIdentityMethodsElemTechnique = "hash-comparison"
const ComponentEvidenceIdentityMethodsElemTechniqueInstrumentation ComponentEvidenceIdentityMethodsElemTechnique = "instrumentation"
const ComponentEvidenceIdentityMethodsElemTechniqueManifestAnalysis ComponentEvidenceIdentityMethodsElemTechnique = "manifest-analysis"
const ComponentEvidenceIdentityMethodsElemTechniqueOther ComponentEvidenceIdentityMethodsElemTechnique = "other"
const ComponentEvidenceIdentityMethodsElemTechniqueSourceCodeAnalysis ComponentEvidenceIdentityMethodsElemTechnique = "source-code-analysis"

type ComponentEvidenceOccurrencesElem struct {
	// An optional identifier which can be used to reference the occurrence elsewhere
	// in the BOM. Every bom-ref MUST be unique within the BOM.
	BomRef *RefType `json:"bom-ref,omitempty" yaml:"bom-ref,omitempty" mapstructure:"bom-ref,omitempty"`

	// The location or path to where the component was found.
	Location string `json:"location" yaml:"location" mapstructure:"location"`
}

// Component pedigree is a way to document complex supply chain scenarios where
// components are created, distributed, modified, redistributed, combined with
// other components, etc. Pedigree supports viewing this complex chain from the
// beginning, the end, or anywhere in the middle. It also provides a way to
// document variants where the exact relation may not be known.
type ComponentPedigree struct {
	// Describes zero or more components in which a component is derived from. This is
	// commonly used to describe forks from existing projects where the forked version
	// contains a ancestor node containing the original component it was forked from.
	// For example, Component A is the original component. Component B is the
	// component being used and documented in the BOM. However, Component B contains a
	// pedigree node with a single ancestor documenting Component A - the original
	// component from which Component B is derived from.
	Ancestors []*Component `json:"ancestors,omitempty" yaml:"ancestors,omitempty" mapstructure:"ancestors,omitempty"`

	// A list of zero or more commits which provide a trail describing how the
	// component deviates from an ancestor, descendant, or variant.
	Commits []Commit `json:"commits,omitempty" yaml:"commits,omitempty" mapstructure:"commits,omitempty"`

	// Descendants are the exact opposite of ancestors. This provides a way to
	// document all forks (and their forks) of an original or root component.
	Descendants []*Component `json:"descendants,omitempty" yaml:"descendants,omitempty" mapstructure:"descendants,omitempty"`

	// Notes, observations, and other non-structured commentary describing the
	// components pedigree.
	Notes *string `json:"notes,omitempty" yaml:"notes,omitempty" mapstructure:"notes,omitempty"`

	// >A list of zero or more patches describing how the component deviates from an
	// ancestor, descendant, or variant. Patches may be complimentary to commits or
	// may be used in place of commits.
	Patches []Patch `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`

	// Variants describe relations where the relationship between the components are
	// not known. For example, if Component A contains nearly identical code to
	// Component B. They are both related, but it is unclear if one is derived from
	// the other, or if they share a common ancestor.
	Variants []*Component `json:"variants,omitempty" yaml:"variants,omitempty" mapstructure:"variants,omitempty"`
}

type ComponentScope string

const ComponentScopeExcluded ComponentScope = "excluded"
const ComponentScopeOptional ComponentScope = "optional"
const ComponentScopeRequired ComponentScope = "required"

// Enveloped signature in [JSON Signature Format
// (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
type ComponentSignature interface{}

type ComponentType string

const ComponentTypeApplication ComponentType = "application"
const ComponentTypeContainer ComponentType = "container"
const ComponentTypeData ComponentType = "data"
const ComponentTypeDevice ComponentType = "device"
const ComponentTypeDeviceDriver ComponentType = "device-driver"
const ComponentTypeFile ComponentType = "file"
const ComponentTypeFirmware ComponentType = "firmware"
const ComponentTypeFramework ComponentType = "framework"
const ComponentTypeLibrary ComponentType = "library"
const ComponentTypeMachineLearningModel ComponentType = "machine-learning-model"
const ComponentTypeOperatingSystem ComponentType = "operating-system"
const ComponentTypePlatform ComponentType = "platform"

type Compositions struct {
	// Specifies an aggregate type that describe how complete a relationship is.
	//
	// * __complete__ = The relationship is complete. No further relationships
	// including constituent components, services, or dependencies are known to exist.
	// * __incomplete__ = The relationship is incomplete. Additional relationships
	// exist and may include constituent components, services, or dependencies.
	// * __incomplete&#95;first&#95;party&#95;only__ = The relationship is incomplete.
	// Only relationships for first-party components, services, or their dependencies
	// are represented.
	// * __incomplete&#95;first&#95;party&#95;proprietary&#95;only__ = The
	// relationship is incomplete. Only relationships for first-party components,
	// services, or their dependencies are represented, limited specifically to those
	// that are proprietary.
	// * __incomplete&#95;first&#95;party&#95;opensource&#95;only__ = The relationship
	// is incomplete. Only relationships for first-party components, services, or
	// their dependencies are represented, limited specifically to those that are
	// opensource.
	// * __incomplete&#95;third&#95;party&#95;only__ = The relationship is incomplete.
	// Only relationships for third-party components, services, or their dependencies
	// are represented.
	// * __incomplete&#95;third&#95;party&#95;proprietary&#95;only__ = The
	// relationship is incomplete. Only relationships for third-party components,
	// services, or their dependencies are represented, limited specifically to those
	// that are proprietary.
	// * __incomplete&#95;third&#95;party&#95;opensource&#95;only__ = The relationship
	// is incomplete. Only relationships for third-party components, services, or
	// their dependencies are represented, limited specifically to those that are
	// opensource.
	// * __unknown__ = The relationship may be complete or incomplete. This usually
	// signifies a 'best-effort' to obtain constituent components, services, or
	// dependencies but the completeness is inconclusive.
	// * __not&#95;specified__ = The relationship completeness is not specified.
	//
	Aggregate AggregateType `json:"aggregate" yaml:"aggregate" mapstructure:"aggregate"`

	// The bom-ref identifiers of the components or services being described.
	// Assemblies refer to nested relationships whereby a constituent part may include
	// other constituent parts. References do not cascade to child parts. References
	// are explicit for the specified constituent part only.
	Assemblies []interface{} `json:"assemblies,omitempty" yaml:"assemblies,omitempty" mapstructure:"assemblies,omitempty"`

	// An optional identifier which can be used to reference the composition elsewhere
	// in the BOM. Every bom-ref MUST be unique within the BOM.
	BomRef *RefType `json:"bom-ref,omitempty" yaml:"bom-ref,omitempty" mapstructure:"bom-ref,omitempty"`

	// The bom-ref identifiers of the components or services being described.
	// Dependencies refer to a relationship whereby an independent constituent part
	// requires another independent constituent part. References do not cascade to
	// transitive dependencies. References are explicit for the specified dependency
	// only.
	Dependencies []string `json:"dependencies,omitempty" yaml:"dependencies,omitempty" mapstructure:"dependencies,omitempty"`

	// Enveloped signature in [JSON Signature Format
	// (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
	Signature CompositionsSignature `json:"signature,omitempty" yaml:"signature,omitempty" mapstructure:"signature,omitempty"`

	// The bom-ref identifiers of the vulnerabilities being described.
	Vulnerabilities []string `json:"vulnerabilities,omitempty" yaml:"vulnerabilities,omitempty" mapstructure:"vulnerabilities,omitempty"`
}

// Enveloped signature in [JSON Signature Format
// (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
type CompositionsSignature interface{}

// A condition that was used to determine a trigger should be activated.
type Condition struct {
	// Describes the set of conditions which cause the trigger to activate.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The logical expression that was evaluated that determined the trigger should be
	// fired.
	Expression *string `json:"expression,omitempty" yaml:"expression,omitempty" mapstructure:"expression,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

type Copyright struct {
	// Text corresponds to the JSON schema field "text".
	Text string `json:"text" yaml:"text" mapstructure:"text"`
}

// Integer representation of a Common Weaknesses Enumerations (CWE). For example
// 399 (of https://cwe.mitre.org/data/definitions/399.html)
type Cwe int

type CycloneDx struct {
	// Schema corresponds to the JSON schema field "$schema".
	Schema *CycloneDxSchema `json:"$schema,omitempty" yaml:"$schema,omitempty" mapstructure:"$schema,omitempty"`

	// Comments made by people, organizations, or tools about any object with a
	// bom-ref, such as components, services, vulnerabilities, or the BOM itself.
	// Unlike inventory information, annotations may contain opinion or commentary
	// from various stakeholders. Annotations may be inline (with inventory) or
	// externalized via BOM-Link, and may optionally be signed.
	Annotations []Annotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Specifies the format of the BOM. This helps to identify the file as CycloneDX
	// since BOMs do not have a filename convention nor does JSON schema support
	// namespaces. This value MUST be "CycloneDX".
	BomFormat CycloneDxBomFormat `json:"bomFormat" yaml:"bomFormat" mapstructure:"bomFormat"`

	// A list of software and hardware components.
	Components []Component `json:"components,omitempty" yaml:"components,omitempty" mapstructure:"components,omitempty"`

	// Compositions describe constituent parts (including components, services, and
	// dependency relationships) and their completeness. The completeness of
	// vulnerabilities expressed in a BOM may also be described.
	Compositions []Compositions `json:"compositions,omitempty" yaml:"compositions,omitempty" mapstructure:"compositions,omitempty"`

	// Provides the ability to document dependency relationships.
	Dependencies []Dependency `json:"dependencies,omitempty" yaml:"dependencies,omitempty" mapstructure:"dependencies,omitempty"`

	// External references provide a way to document systems, sites, and information
	// that may be relevant, but are not included with the BOM. They may also
	// establish specific relationships within or external to the BOM.
	ExternalReferences []ExternalReference `json:"externalReferences,omitempty" yaml:"externalReferences,omitempty" mapstructure:"externalReferences,omitempty"`

	// Describes how a component or service was manufactured or deployed. This is
	// achieved through the use of formulas, workflows, tasks, and steps, which
	// declare the precise steps to reproduce along with the observed formulas
	// describing the steps which transpired in the manufacturing process.
	Formulation []Formula `json:"formulation,omitempty" yaml:"formulation,omitempty" mapstructure:"formulation,omitempty"`

	// Provides additional information about a BOM.
	Metadata *Metadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// Provides the ability to document properties in a name-value store. This
	// provides flexibility to include data not officially supported in the standard
	// without having to use additional namespaces or create extensions. Unlike
	// key-value stores, properties support duplicate names, each potentially having
	// different values. Property names of interest to the general public are
	// encouraged to be registered in the [CycloneDX Property
	// Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal
	// registration is OPTIONAL.
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// Every BOM generated SHOULD have a unique serial number, even if the contents of
	// the BOM have not changed over time. If specified, the serial number MUST
	// conform to RFC-4122. Use of serial numbers are RECOMMENDED.
	SerialNumber *string `json:"serialNumber,omitempty" yaml:"serialNumber,omitempty" mapstructure:"serialNumber,omitempty"`

	// A list of services. This may include microservices, function-as-a-service, and
	// other types of network or intra-process services.
	Services []Service `json:"services,omitempty" yaml:"services,omitempty" mapstructure:"services,omitempty"`

	// Enveloped signature in [JSON Signature Format
	// (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
	Signature CycloneDxSignature `json:"signature,omitempty" yaml:"signature,omitempty" mapstructure:"signature,omitempty"`

	// The version of the CycloneDX specification a BOM conforms to (starting at
	// version 1.2).
	SpecVersion string `json:"specVersion" yaml:"specVersion" mapstructure:"specVersion"`

	// Whenever an existing BOM is modified, either manually or through automated
	// processes, the version of the BOM SHOULD be incremented by 1. When a system is
	// presented with multiple BOMs with identical serial numbers, the system SHOULD
	// use the most recent version of the BOM. The default version is '1'.
	Version int `json:"version" yaml:"version" mapstructure:"version"`

	// Vulnerabilities identified in components or services.
	Vulnerabilities []Vulnerability `json:"vulnerabilities,omitempty" yaml:"vulnerabilities,omitempty" mapstructure:"vulnerabilities,omitempty"`
}

type CycloneDxBomFormat string

const CycloneDxBomFormatCycloneDX CycloneDxBomFormat = "CycloneDX"

type CycloneDxSchema string

const CycloneDxSchemaHttpCyclonedxOrgSchemaBom15SchemaJson CycloneDxSchema = "http://cyclonedx.org/schema/bom-1.5.schema.json"

// Enveloped signature in [JSON Signature Format
// (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
type CycloneDxSignature interface{}

// Data classification tags data according to its type, sensitivity, and value if
// altered, stolen, or destroyed.
type DataClassification string

type DataFlowDirection string

const DataFlowDirectionBiDirectional DataFlowDirection = "bi-directional"
const DataFlowDirectionInbound DataFlowDirection = "inbound"
const DataFlowDirectionOutbound DataFlowDirection = "outbound"
const DataFlowDirectionUnknown DataFlowDirection = "unknown"

type DataGovernance struct {
	// Data custodians are responsible for the safe custody, transport, and storage of
	// data.
	Custodians []DataGovernanceResponsibleParty `json:"custodians,omitempty" yaml:"custodians,omitempty" mapstructure:"custodians,omitempty"`

	// Data owners are concerned with risk and appropriate access to data.
	Owners []DataGovernanceResponsibleParty `json:"owners,omitempty" yaml:"owners,omitempty" mapstructure:"owners,omitempty"`

	// Data stewards are responsible for data content, context, and associated
	// business rules.
	Stewards []DataGovernanceResponsibleParty `json:"stewards,omitempty" yaml:"stewards,omitempty" mapstructure:"stewards,omitempty"`
}

type DataGovernanceResponsibleParty struct {
	// Contact corresponds to the JSON schema field "contact".
	Contact *OrganizationalContact `json:"contact,omitempty" yaml:"contact,omitempty" mapstructure:"contact,omitempty"`

	// Organization corresponds to the JSON schema field "organization".
	Organization *OrganizationalEntity `json:"organization,omitempty" yaml:"organization,omitempty" mapstructure:"organization,omitempty"`
}

// Defines the direct dependencies of a component or service. Components or
// services that do not have their own dependencies MUST be declared as empty
// elements within the graph. Components or services that are not represented in
// the dependency graph MAY have unknown dependencies. It is RECOMMENDED that
// implementations assume this to be opaque and not an indicator of a object being
// dependency-free. It is RECOMMENDED to leverage compositions to indicate unknown
// dependency graphs.
type Dependency struct {
	// The bom-ref identifiers of the components or services that are dependencies of
	// this dependency object.
	DependsOn []DependencyDependsOnElem `json:"dependsOn,omitempty" yaml:"dependsOn,omitempty" mapstructure:"dependsOn,omitempty"`

	// References a component or service by its bom-ref attribute
	Ref DependencyRef `json:"ref" yaml:"ref" mapstructure:"ref"`
}

type DependencyDependsOnElem interface{}

// References a component or service by its bom-ref attribute
type DependencyRef interface{}

// The patch file (or diff) that show changes. Refer to
// https://en.wikipedia.org/wiki/Diff
type Diff struct {
	// Specifies the optional text of the diff
	Text *Attachment `json:"text,omitempty" yaml:"text,omitempty" mapstructure:"text,omitempty"`

	// Specifies the URL to the diff
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

// Represents something that happened that may trigger a response.
type Event struct {
	// Encoding of the raw event data.
	Data *Attachment `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// A description of the event.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// References the component or service that was the source of the event
	Source *ResourceReferenceChoice `json:"source,omitempty" yaml:"source,omitempty" mapstructure:"source,omitempty"`

	// References the component or service that was the target of the event
	Target *ResourceReferenceChoice `json:"target,omitempty" yaml:"target,omitempty" mapstructure:"target,omitempty"`

	// The date and time (timestamp) when the event was received.
	TimeReceived *time.Time `json:"timeReceived,omitempty" yaml:"timeReceived,omitempty" mapstructure:"timeReceived,omitempty"`

	// The unique identifier of the event.
	Uid *string `json:"uid,omitempty" yaml:"uid,omitempty" mapstructure:"uid,omitempty"`
}

// External references provide a way to document systems, sites, and information
// that may be relevant, but are not included with the BOM. They may also establish
// specific relationships within or external to the BOM.
type ExternalReference struct {
	// An optional comment describing the external reference
	Comment *string `json:"comment,omitempty" yaml:"comment,omitempty" mapstructure:"comment,omitempty"`

	// The hashes of the external reference (if applicable).
	Hashes []Hash `json:"hashes,omitempty" yaml:"hashes,omitempty" mapstructure:"hashes,omitempty"`

	// Specifies the type of external reference.
	//
	// * __vcs__ = Version Control System
	// * __issue-tracker__ = Issue or defect tracking system, or an Application
	// Lifecycle Management (ALM) system
	// * __website__ = Website
	// * __advisories__ = Security advisories
	// * __bom__ = Bill of Materials (SBOM, OBOM, HBOM, SaaSBOM, etc)
	// * __mailing-list__ = Mailing list or discussion group
	// * __social__ = Social media account
	// * __chat__ = Real-time chat platform
	// * __documentation__ = Documentation, guides, or how-to instructions
	// * __support__ = Community or commercial support
	// * __distribution__ = Direct or repository download location
	// * __distribution-intake__ = The location where a component was published to.
	// This is often the same as "distribution" but may also include specialized
	// publishing processes that act as an intermediary
	// * __license__ = The URL to the license file. If a license URL has been defined
	// in the license node, it should also be defined as an external reference for
	// completeness
	// * __build-meta__ = Build-system specific meta file (i.e. pom.xml, package.json,
	// .nuspec, etc)
	// * __build-system__ = URL to an automated build system
	// * __release-notes__ = URL to release notes
	// * __security-contact__ = Specifies a way to contact the maintainer, supplier,
	// or provider in the event of a security incident. Common URIs include links to a
	// disclosure procedure, a mailto (RFC-2368) that specifies an email address, a
	// tel (RFC-3966) that specifies a phone number, or dns (RFC-4501) that specifies
	// the records containing DNS Security TXT
	// * __model-card__ = A model card describes the intended uses of a machine
	// learning model, potential limitations, biases, ethical considerations, training
	// parameters, datasets used to train the model, performance metrics, and other
	// relevant data useful for ML transparency
	// * __log__ = A record of events that occurred in a computer system or
	// application, such as problems, errors, or information on current operations
	// * __configuration__ = Parameters or settings that may be used by other
	// components or services
	// * __evidence__ = Information used to substantiate a claim
	// * __formulation__ = Describes how a component or service was manufactured or
	// deployed
	// * __attestation__ = Human or machine-readable statements containing facts,
	// evidence, or testimony
	// * __threat-model__ = An enumeration of identified weaknesses, threats, and
	// countermeasures, dataflow diagram (DFD), attack tree, and other supporting
	// documentation in human-readable or machine-readable format
	// * __adversary-model__ = The defined assumptions, goals, and capabilities of an
	// adversary.
	// * __risk-assessment__ = Identifies and analyzes the potential of future events
	// that may negatively impact individuals, assets, and/or the environment. Risk
	// assessments may also include judgments on the tolerability of each risk.
	// * __vulnerability-assertion__ = A Vulnerability Disclosure Report (VDR) which
	// asserts the known and previously unknown vulnerabilities that affect a
	// component, service, or product including the analysis and findings describing
	// the impact (or lack of impact) that the reported vulnerability has on a
	// component, service, or product.
	// * __exploitability-statement__ = A Vulnerability Exploitability eXchange (VEX)
	// which asserts the known vulnerabilities that do not affect a product, product
	// family, or organization, and optionally the ones that do. The VEX should
	// include the analysis and findings describing the impact (or lack of impact)
	// that the reported vulnerability has on the product, product family, or
	// organization.
	// * __pentest-report__ = Results from an authorized simulated cyberattack on a
	// component or service, otherwise known as a penetration test
	// * __static-analysis-report__ = SARIF or proprietary machine or human-readable
	// report for which static analysis has identified code quality, security, and
	// other potential issues with the source code
	// * __dynamic-analysis-report__ = Dynamic analysis report that has identified
	// issues such as vulnerabilities and misconfigurations
	// * __runtime-analysis-report__ = Report generated by analyzing the call stack of
	// a running application
	// * __component-analysis-report__ = Report generated by Software Composition
	// Analysis (SCA), container analysis, or other forms of component analysis
	// * __maturity-report__ = Report containing a formal assessment of an
	// organization, business unit, or team against a maturity model
	// * __certification-report__ = Industry, regulatory, or other certification from
	// an accredited (if applicable) certification body
	// * __quality-metrics__ = Report or system in which quality metrics can be
	// obtained
	// * __codified-infrastructure__ = Code or configuration that defines and
	// provisions virtualized infrastructure, commonly referred to as Infrastructure
	// as Code (IaC)
	// * __poam__ = Plans of Action and Milestones (POAM) compliment an "attestation"
	// external reference. POAM is defined by NIST as a "document that identifies
	// tasks needing to be accomplished. It details resources required to accomplish
	// the elements of the plan, any milestones in meeting the tasks and scheduled
	// completion dates for the milestones".
	// * __other__ = Use this if no other types accurately describe the purpose of the
	// external reference
	Type ExternalReferenceType `json:"type" yaml:"type" mapstructure:"type"`

	// The URI (URL or URN) to the external reference. External references are URIs
	// and therefore can accept any URL scheme including https
	// ([RFC-7230](https://www.ietf.org/rfc/rfc7230.txt)), mailto
	// ([RFC-2368](https://www.ietf.org/rfc/rfc2368.txt)), tel
	// ([RFC-3966](https://www.ietf.org/rfc/rfc3966.txt)), and dns
	// ([RFC-4501](https://www.ietf.org/rfc/rfc4501.txt)). External references may
	// also include formally registered URNs such as [CycloneDX
	// BOM-Link](https://cyclonedx.org/capabilities/bomlink/) to reference CycloneDX
	// BOMs or any object within a BOM. BOM-Link transforms applicable external
	// references into relationships that can be expressed in a BOM or across BOMs.
	Url interface{} `json:"url" yaml:"url" mapstructure:"url"`
}

type ExternalReferenceType string

const ExternalReferenceTypeAdversaryModel ExternalReferenceType = "adversary-model"
const ExternalReferenceTypeAdvisories ExternalReferenceType = "advisories"
const ExternalReferenceTypeAttestation ExternalReferenceType = "attestation"
const ExternalReferenceTypeBom ExternalReferenceType = "bom"
const ExternalReferenceTypeBuildMeta ExternalReferenceType = "build-meta"
const ExternalReferenceTypeBuildSystem ExternalReferenceType = "build-system"
const ExternalReferenceTypeCertificationReport ExternalReferenceType = "certification-report"
const ExternalReferenceTypeChat ExternalReferenceType = "chat"
const ExternalReferenceTypeCodifiedInfrastructure ExternalReferenceType = "codified-infrastructure"
const ExternalReferenceTypeComponentAnalysisReport ExternalReferenceType = "component-analysis-report"
const ExternalReferenceTypeConfiguration ExternalReferenceType = "configuration"
const ExternalReferenceTypeDistribution ExternalReferenceType = "distribution"
const ExternalReferenceTypeDistributionIntake ExternalReferenceType = "distribution-intake"
const ExternalReferenceTypeDocumentation ExternalReferenceType = "documentation"
const ExternalReferenceTypeDynamicAnalysisReport ExternalReferenceType = "dynamic-analysis-report"
const ExternalReferenceTypeEvidence ExternalReferenceType = "evidence"
const ExternalReferenceTypeExploitabilityStatement ExternalReferenceType = "exploitability-statement"
const ExternalReferenceTypeFormulation ExternalReferenceType = "formulation"
const ExternalReferenceTypeIssueTracker ExternalReferenceType = "issue-tracker"
const ExternalReferenceTypeLicense ExternalReferenceType = "license"
const ExternalReferenceTypeLog ExternalReferenceType = "log"
const ExternalReferenceTypeMailingList ExternalReferenceType = "mailing-list"
const ExternalReferenceTypeMaturityReport ExternalReferenceType = "maturity-report"
const ExternalReferenceTypeModelCard ExternalReferenceType = "model-card"
const ExternalReferenceTypeOther ExternalReferenceType = "other"
const ExternalReferenceTypePentestReport ExternalReferenceType = "pentest-report"
const ExternalReferenceTypePoam ExternalReferenceType = "poam"
const ExternalReferenceTypeQualityMetrics ExternalReferenceType = "quality-metrics"
const ExternalReferenceTypeReleaseNotes ExternalReferenceType = "release-notes"
const ExternalReferenceTypeRiskAssessment ExternalReferenceType = "risk-assessment"
const ExternalReferenceTypeRuntimeAnalysisReport ExternalReferenceType = "runtime-analysis-report"
const ExternalReferenceTypeSecurityContact ExternalReferenceType = "security-contact"
const ExternalReferenceTypeSocial ExternalReferenceType = "social"
const ExternalReferenceTypeStaticAnalysisReport ExternalReferenceType = "static-analysis-report"
const ExternalReferenceTypeSupport ExternalReferenceType = "support"
const ExternalReferenceTypeThreatModel ExternalReferenceType = "threat-model"
const ExternalReferenceTypeVcs ExternalReferenceType = "vcs"
const ExternalReferenceTypeVulnerabilityAssertion ExternalReferenceType = "vulnerability-assertion"
const ExternalReferenceTypeWebsite ExternalReferenceType = "website"

// Information about the benefits and harms of the model to an identified at risk
// group.
type FairnessAssessment struct {
	// Expected benefits to the identified groups.
	Benefits *string `json:"benefits,omitempty" yaml:"benefits,omitempty" mapstructure:"benefits,omitempty"`

	// The groups or individuals at risk of being systematically disadvantaged by the
	// model.
	GroupAtRisk *string `json:"groupAtRisk,omitempty" yaml:"groupAtRisk,omitempty" mapstructure:"groupAtRisk,omitempty"`

	// Expected harms to the identified groups.
	Harms *string `json:"harms,omitempty" yaml:"harms,omitempty" mapstructure:"harms,omitempty"`

	// With respect to the benefits and harms outlined, please describe any mitigation
	// strategy implemented.
	MitigationStrategy *string `json:"mitigationStrategy,omitempty" yaml:"mitigationStrategy,omitempty" mapstructure:"mitigationStrategy,omitempty"`
}

// Describes workflows and resources that captures rules and other aspects of how
// the associated BOM component or service was formed.
type Formula struct {
	// An optional identifier which can be used to reference the formula elsewhere in
	// the BOM. Every bom-ref MUST be unique within the BOM.
	BomRef *RefType `json:"bom-ref,omitempty" yaml:"bom-ref,omitempty" mapstructure:"bom-ref,omitempty"`

	// Transient components that are used in tasks that constitute one or more of this
	// formula's workflows
	Components []Component `json:"components,omitempty" yaml:"components,omitempty" mapstructure:"components,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// Transient services that are used in tasks that constitute one or more of this
	// formula's workflows
	Services []Service `json:"services,omitempty" yaml:"services,omitempty" mapstructure:"services,omitempty"`

	// List of workflows that can be declared to accomplish specific orchestrated
	// goals and independently triggered.
	Workflows []Workflow `json:"workflows,omitempty" yaml:"workflows,omitempty" mapstructure:"workflows,omitempty"`
}

type Graphic struct {
	// The graphic (vector or raster). Base64 encoding MUST be specified for binary
	// images.
	Image *Attachment `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// The name of the graphic.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// A collection of graphics that represent various measurements.
type GraphicsCollection struct {
	// A collection of graphics.
	Collection []Graphic `json:"collection,omitempty" yaml:"collection,omitempty" mapstructure:"collection,omitempty"`

	// A description of this collection of graphics.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`
}

type Hash struct {
	// Alg corresponds to the JSON schema field "alg".
	Alg HashAlg `json:"alg" yaml:"alg" mapstructure:"alg"`

	// Content corresponds to the JSON schema field "content".
	Content HashContent `json:"content" yaml:"content" mapstructure:"content"`
}

type HashAlg string

const HashAlgBLAKE2B256 HashAlg = "BLAKE2b-256"
const HashAlgBLAKE2B384 HashAlg = "BLAKE2b-384"
const HashAlgBLAKE2B512 HashAlg = "BLAKE2b-512"
const HashAlgBLAKE3 HashAlg = "BLAKE3"
const HashAlgMD5 HashAlg = "MD5"
const HashAlgSHA1 HashAlg = "SHA-1"
const HashAlgSHA256 HashAlg = "SHA-256"
const HashAlgSHA3256 HashAlg = "SHA3-256"
const HashAlgSHA3384 HashAlg = "SHA3-384"
const HashAlgSHA3512 HashAlg = "SHA3-512"
const HashAlgSHA384 HashAlg = "SHA-384"
const HashAlgSHA512 HashAlg = "SHA-512"

type HashContent string

// Specifies an individual commit
type IdentifiableAction struct {
	// The email address of the individual who performed the action
	Email *string `json:"email,omitempty" yaml:"email,omitempty" mapstructure:"email,omitempty"`

	// The name of the individual who performed the action
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The timestamp in which the action occurred
	Timestamp *time.Time `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`
}

type ImpactAnalysisJustification string

const ImpactAnalysisJustificationCodeNotPresent ImpactAnalysisJustification = "code_not_present"
const ImpactAnalysisJustificationCodeNotReachable ImpactAnalysisJustification = "code_not_reachable"
const ImpactAnalysisJustificationProtectedAtPerimeter ImpactAnalysisJustification = "protected_at_perimeter"
const ImpactAnalysisJustificationProtectedAtRuntime ImpactAnalysisJustification = "protected_at_runtime"
const ImpactAnalysisJustificationProtectedByCompiler ImpactAnalysisJustification = "protected_by_compiler"
const ImpactAnalysisJustificationProtectedByMitigatingControl ImpactAnalysisJustification = "protected_by_mitigating_control"
const ImpactAnalysisJustificationRequiresConfiguration ImpactAnalysisJustification = "requires_configuration"
const ImpactAnalysisJustificationRequiresDependency ImpactAnalysisJustification = "requires_dependency"
const ImpactAnalysisJustificationRequiresEnvironment ImpactAnalysisJustification = "requires_environment"

type ImpactAnalysisState string

const ImpactAnalysisStateExploitable ImpactAnalysisState = "exploitable"
const ImpactAnalysisStateFalsePositive ImpactAnalysisState = "false_positive"
const ImpactAnalysisStateInTriage ImpactAnalysisState = "in_triage"
const ImpactAnalysisStateNotAffected ImpactAnalysisState = "not_affected"
const ImpactAnalysisStateResolved ImpactAnalysisState = "resolved"
const ImpactAnalysisStateResolvedWithPedigree ImpactAnalysisState = "resolved_with_pedigree"

type InputOutputMLParameters struct {
	// The data format for input/output to the model. Example formats include string,
	// image, time-series
	Format *string `json:"format,omitempty" yaml:"format,omitempty" mapstructure:"format,omitempty"`
}

// Type that represents various input data types and formats.
type InputType struct {
	// Inputs that have the form of data.
	Data *Attachment `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// Inputs that have the form of parameters with names and values.
	EnvironmentVars []interface{} `json:"environmentVars,omitempty" yaml:"environmentVars,omitempty" mapstructure:"environmentVars,omitempty"`

	// Inputs that have the form of parameters with names and values.
	Parameters []Parameter `json:"parameters,omitempty" yaml:"parameters,omitempty" mapstructure:"parameters,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// A reference to an independent resource provided as an input to a task by the
	// workflow runtime.
	Resource *ResourceReferenceChoice `json:"resource,omitempty" yaml:"resource,omitempty" mapstructure:"resource,omitempty"`

	// A references to the component or service that provided the input to the task
	// (e.g., reference to a service with data flow value of `inbound`)
	Source *ResourceReferenceChoice `json:"source,omitempty" yaml:"source,omitempty" mapstructure:"source,omitempty"`

	// A reference to the component or service that received or stored the input if
	// not the task itself (e.g., a local, named storage workspace)
	Target *ResourceReferenceChoice `json:"target,omitempty" yaml:"target,omitempty" mapstructure:"target,omitempty"`
}

// An individual issue that has been resolved.
type Issue struct {
	// A description of the issue
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The identifier of the issue assigned by the source of the issue
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// The name of the issue
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// A collection of URL's for reference. Multiple URLs are allowed.
	References []string `json:"references,omitempty" yaml:"references,omitempty" mapstructure:"references,omitempty"`

	// The source of the issue where it is documented
	Source *IssueSource `json:"source,omitempty" yaml:"source,omitempty" mapstructure:"source,omitempty"`

	// Specifies the type of issue
	Type IssueType `json:"type" yaml:"type" mapstructure:"type"`
}

// The source of the issue where it is documented
type IssueSource struct {
	// The name of the source. For example 'National Vulnerability Database', 'NVD',
	// and 'Apache'
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The url of the issue documentation as provided by the source
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

type IssueType string

const IssueTypeDefect IssueType = "defect"
const IssueTypeEnhancement IssueType = "enhancement"
const IssueTypeSecurity IssueType = "security"



// EITHER (list of SPDX licenses and/or named licenses) OR (tuple of one SPDX
// License Expression)
type LicenseChoice []map[string]interface{}

// Licensing details describing the licensor/licensee, license type, renewal and
// expiration dates, and other important metadata
type LicenseLicensing struct {
	// License identifiers that may be used to manage licenses and their lifecycle
	AltIds []string `json:"altIds,omitempty" yaml:"altIds,omitempty" mapstructure:"altIds,omitempty"`

	// The timestamp indicating when the current license expires (if applicable).
	Expiration *time.Time `json:"expiration,omitempty" yaml:"expiration,omitempty" mapstructure:"expiration,omitempty"`

	// The timestamp indicating when the license was last renewed. For new purchases,
	// this is often the purchase or acquisition date. For non-perpetual licenses or
	// subscriptions, this is the timestamp of when the license was last renewed.
	LastRenewal *time.Time `json:"lastRenewal,omitempty" yaml:"lastRenewal,omitempty" mapstructure:"lastRenewal,omitempty"`

	// The type of license(s) that was granted to the licensee
	//
	// * __academic__ = A license that grants use of software solely for the purpose
	// of education or research.
	// * __appliance__ = A license covering use of software embedded in a specific
	// piece of hardware.
	// * __client-access__ = A Client Access License (CAL) allows client computers to
	// access services provided by server software.
	// * __concurrent-user__ = A Concurrent User license (aka floating license) limits
	// the number of licenses for a software application and licenses are shared among
	// a larger number of users.
	// * __core-points__ = A license where the core of a computer's processor is
	// assigned a specific number of points.
	// * __custom-metric__ = A license for which consumption is measured by
	// non-standard metrics.
	// * __device__ = A license that covers a defined number of installations on
	// computers and other types of devices.
	// * __evaluation__ = A license that grants permission to install and use software
	// for trial purposes.
	// * __named-user__ = A license that grants access to the software to one or more
	// pre-defined users.
	// * __node-locked__ = A license that grants access to the software on one or more
	// pre-defined computers or devices.
	// * __oem__ = An Original Equipment Manufacturer license that is delivered with
	// hardware, cannot be transferred to other hardware, and is valid for the life of
	// the hardware.
	// * __perpetual__ = A license where the software is sold on a one-time basis and
	// the licensee can use a copy of the software indefinitely.
	// * __processor-points__ = A license where each installation consumes points per
	// processor.
	// * __subscription__ = A license where the licensee pays a fee to use the
	// software or service.
	// * __user__ = A license that grants access to the software or service by a
	// specified number of users.
	// * __other__ = Another license type.
	//
	LicenseTypes []LicenseLicensingLicenseTypesElem `json:"licenseTypes,omitempty" yaml:"licenseTypes,omitempty" mapstructure:"licenseTypes,omitempty"`

	// The individual or organization for which a license was granted to
	Licensee *LicenseLicensingLicensee `json:"licensee,omitempty" yaml:"licensee,omitempty" mapstructure:"licensee,omitempty"`

	// The individual or organization that grants a license to another individual or
	// organization
	Licensor *LicenseLicensingLicensor `json:"licensor,omitempty" yaml:"licensor,omitempty" mapstructure:"licensor,omitempty"`

	// The purchase order identifier the purchaser sent to a supplier or vendor to
	// authorize a purchase
	PurchaseOrder *string `json:"purchaseOrder,omitempty" yaml:"purchaseOrder,omitempty" mapstructure:"purchaseOrder,omitempty"`

	// The individual or organization that purchased the license
	Purchaser *LicenseLicensingPurchaser `json:"purchaser,omitempty" yaml:"purchaser,omitempty" mapstructure:"purchaser,omitempty"`
}

type LicenseLicensingLicenseTypesElem string

const LicenseLicensingLicenseTypesElemAcademic LicenseLicensingLicenseTypesElem = "academic"
const LicenseLicensingLicenseTypesElemAppliance LicenseLicensingLicenseTypesElem = "appliance"
const LicenseLicensingLicenseTypesElemClientAccess LicenseLicensingLicenseTypesElem = "client-access"
const LicenseLicensingLicenseTypesElemConcurrentUser LicenseLicensingLicenseTypesElem = "concurrent-user"
const LicenseLicensingLicenseTypesElemCorePoints LicenseLicensingLicenseTypesElem = "core-points"
const LicenseLicensingLicenseTypesElemCustomMetric LicenseLicensingLicenseTypesElem = "custom-metric"
const LicenseLicensingLicenseTypesElemDevice LicenseLicensingLicenseTypesElem = "device"
const LicenseLicensingLicenseTypesElemEvaluation LicenseLicensingLicenseTypesElem = "evaluation"
const LicenseLicensingLicenseTypesElemNamedUser LicenseLicensingLicenseTypesElem = "named-user"
const LicenseLicensingLicenseTypesElemNodeLocked LicenseLicensingLicenseTypesElem = "node-locked"
const LicenseLicensingLicenseTypesElemOem LicenseLicensingLicenseTypesElem = "oem"
const LicenseLicensingLicenseTypesElemOther LicenseLicensingLicenseTypesElem = "other"
const LicenseLicensingLicenseTypesElemPerpetual LicenseLicensingLicenseTypesElem = "perpetual"

// UnmarshalJSON implements json.Unmarshaler.
func (j *Note) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["text"]; !ok || v == nil {
		return fmt.Errorf("field text in Note: required")
	}
	type Plain Note
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Note(plain)
	return nil
}

var enumValues_ComponentType = []interface{}{
	"application",
	"framework",
	"library",
	"container",
	"platform",
	"operating-system",
	"device",
	"device-driver",
	"firmware",
	"file",
	"machine-learning-model",
	"data",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Swid) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in Swid: required")
	}
	if v, ok := raw["tagId"]; !ok || v == nil {
		return fmt.Errorf("field tagId in Swid: required")
	}
	type Plain Swid
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["patch"]; !ok || v == nil {
		plain.Patch = false
	}
	if v, ok := raw["tagVersion"]; !ok || v == nil {
		plain.TagVersion = 0.0
	}
	if v, ok := raw["version"]; !ok || v == nil {
		plain.Version = "0.0"
	}
	*j = Swid(plain)
	return nil
}

// Specifies metadata and content for ISO-IEC 19770-2 Software Identification
// (SWID) Tags.
type Swid struct {
	// Maps to the name of a SoftwareIdentity.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Maps to the patch of a SoftwareIdentity.
	Patch bool `json:"patch,omitempty" yaml:"patch,omitempty" mapstructure:"patch,omitempty"`

	// Maps to the tagId of a SoftwareIdentity.
	TagId string `json:"tagId" yaml:"tagId" mapstructure:"tagId"`

	// Maps to the tagVersion of a SoftwareIdentity.
	TagVersion int `json:"tagVersion,omitempty" yaml:"tagVersion,omitempty" mapstructure:"tagVersion,omitempty"`

	// Specifies the metadata and content of the SWID tag.
	Text *Attachment `json:"text,omitempty" yaml:"text,omitempty" mapstructure:"text,omitempty"`

	// The URL to the SWID file.
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// Maps to the version of a SoftwareIdentity.
	Version string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Hash) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["alg"]; !ok || v == nil {
		return fmt.Errorf("field alg in Hash: required")
	}
	if v, ok := raw["content"]; !ok || v == nil {
		return fmt.Errorf("field content in Hash: required")
	}
	type Plain Hash
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Hash(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentScope) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ComponentScope {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ComponentScope, v)
	}
	*j = ComponentScope(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HashAlg) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_HashAlg {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_HashAlg, v)
	}
	*j = HashAlg(v)
	return nil
}

var enumValues_HashAlg = []interface{}{
	"MD5",
	"SHA-1",
	"SHA-256",
	"SHA-384",
	"SHA-512",
	"SHA3-256",
	"SHA3-384",
	"SHA3-512",
	"BLAKE2b-256",
	"BLAKE2b-384",
	"BLAKE2b-512",
	"BLAKE3",
}
var enumValues_ComponentScope = []interface{}{
	"required",
	"optional",
	"excluded",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Component) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in Component: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in Component: required")
	}
	type Plain Component
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["scope"]; !ok || v == nil {
		plain.Scope = "required"
	}
	*j = Component(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentEvidenceOccurrencesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["location"]; !ok || v == nil {
		return fmt.Errorf("field location in ComponentEvidenceOccurrencesElem: required")
	}
	type Plain ComponentEvidenceOccurrencesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ComponentEvidenceOccurrencesElem(plain)
	return nil
}

var enumValues_DataFlowDirection = []interface{}{
	"inbound",
	"outbound",
	"bi-directional",
	"unknown",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DataFlowDirection) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DataFlowDirection {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DataFlowDirection, v)
	}
	*j = DataFlowDirection(v)
	return nil
}

var enumValues_ExternalReferenceType = []interface{}{
	"vcs",
	"issue-tracker",
	"website",
	"advisories",
	"bom",
	"mailing-list",
	"social",
	"chat",
	"documentation",
	"support",
	"distribution",
	"distribution-intake",
	"license",
	"build-meta",
	"build-system",
	"release-notes",
	"security-contact",
	"model-card",
	"log",
	"configuration",
	"evidence",
	"formulation",
	"attestation",
	"threat-model",
	"adversary-model",
	"risk-assessment",
	"vulnerability-assertion",
	"exploitability-statement",
	"pentest-report",
	"static-analysis-report",
	"dynamic-analysis-report",
	"runtime-analysis-report",
	"component-analysis-report",
	"maturity-report",
	"certification-report",
	"codified-infrastructure",
	"quality-metrics",
	"poam",
	"other",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentEvidenceIdentity) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["field"]; !ok || v == nil {
		return fmt.Errorf("field field in ComponentEvidenceIdentity: required")
	}
	type Plain ComponentEvidenceIdentity
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ComponentEvidenceIdentity(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentEvidenceIdentityMethodsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["confidence"]; !ok || v == nil {
		return fmt.Errorf("field confidence in ComponentEvidenceIdentityMethodsElem: required")
	}
	if v, ok := raw["technique"]; !ok || v == nil {
		return fmt.Errorf("field technique in ComponentEvidenceIdentityMethodsElem: required")
	}
	type Plain ComponentEvidenceIdentityMethodsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ComponentEvidenceIdentityMethodsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentEvidenceIdentityMethodsElemTechnique) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ComponentEvidenceIdentityMethodsElemTechnique {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ComponentEvidenceIdentityMethodsElemTechnique, v)
	}
	*j = ComponentEvidenceIdentityMethodsElemTechnique(v)
	return nil
}

type ServiceData struct {
	// Classification corresponds to the JSON schema field "classification".
	Classification DataClassification `json:"classification" yaml:"classification" mapstructure:"classification"`

	// Short description of the data content and usage
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The URI, URL, or BOM-Link of the components or services the data is sent to
	Destination []interface{} `json:"destination,omitempty" yaml:"destination,omitempty" mapstructure:"destination,omitempty"`

	// Specifies the flow direction of the data. Direction is relative to the service.
	// Inbound flow states that data enters the service. Outbound flow states that
	// data leaves the service. Bi-directional states that data flows both ways, and
	// unknown states that the direction is not known.
	Flow DataFlowDirection `json:"flow" yaml:"flow" mapstructure:"flow"`

	// Governance corresponds to the JSON schema field "governance".
	Governance *DataGovernance `json:"governance,omitempty" yaml:"governance,omitempty" mapstructure:"governance,omitempty"`

	// Name for the defined data
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The URI, URL, or BOM-Link of the components or services the data came in from
	Source []interface{} `json:"source,omitempty" yaml:"source,omitempty" mapstructure:"source,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ServiceData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["classification"]; !ok || v == nil {
		return fmt.Errorf("field classification in ServiceData: required")
	}
	if v, ok := raw["flow"]; !ok || v == nil {
		return fmt.Errorf("field flow in ServiceData: required")
	}
	type Plain ServiceData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ServiceData(plain)
	return nil
}

// Enveloped signature in [JSON Signature Format
// (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
type ServiceSignature interface{}

type Service struct {
	// A boolean value indicating if the service requires authentication. A value of
	// true indicates the service requires authentication prior to use. A value of
	// false indicates the service does not require authentication.
	Authenticated *bool `json:"authenticated,omitempty" yaml:"authenticated,omitempty" mapstructure:"authenticated,omitempty"`

	// An optional identifier which can be used to reference the service elsewhere in
	// the BOM. Every bom-ref MUST be unique within the BOM.
	BomRef *RefType `json:"bom-ref,omitempty" yaml:"bom-ref,omitempty" mapstructure:"bom-ref,omitempty"`

	// Specifies information about the data including the directional flow of data and
	// the data classification.
	Data []ServiceData `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// Specifies a description for the service
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The endpoint URIs of the service. Multiple endpoints are allowed.
	Endpoints []string `json:"endpoints,omitempty" yaml:"endpoints,omitempty" mapstructure:"endpoints,omitempty"`

	// External references provide a way to document systems, sites, and information
	// that may be relevant, but are not included with the BOM. They may also
	// establish specific relationships within or external to the BOM.
	ExternalReferences []ExternalReference `json:"externalReferences,omitempty" yaml:"externalReferences,omitempty" mapstructure:"externalReferences,omitempty"`

	// The grouping name, namespace, or identifier. This will often be a shortened,
	// single name of the company or project that produced the service or domain name.
	// Whitespace and special characters should be avoided.
	Group *string `json:"group,omitempty" yaml:"group,omitempty" mapstructure:"group,omitempty"`

	// Licenses corresponds to the JSON schema field "licenses".
	Licenses LicenseChoice `json:"licenses,omitempty" yaml:"licenses,omitempty" mapstructure:"licenses,omitempty"`

	// The name of the service. This will often be a shortened, single name of the
	// service.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Provides the ability to document properties in a name-value store. This
	// provides flexibility to include data not officially supported in the standard
	// without having to use additional namespaces or create extensions. Unlike
	// key-value stores, properties support duplicate names, each potentially having
	// different values. Property names of interest to the general public are
	// encouraged to be registered in the [CycloneDX Property
	// Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal
	// registration is OPTIONAL.
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The organization that provides the service.
	Provider *OrganizationalEntity `json:"provider,omitempty" yaml:"provider,omitempty" mapstructure:"provider,omitempty"`

	// Specifies optional release notes.
	ReleaseNotes *ReleaseNotes `json:"releaseNotes,omitempty" yaml:"releaseNotes,omitempty" mapstructure:"releaseNotes,omitempty"`

	// A list of services included or deployed behind the parent service. This is not
	// a dependency tree. It provides a way to specify a hierarchical representation
	// of service assemblies.
	Services []*Service `json:"services,omitempty" yaml:"services,omitempty" mapstructure:"services,omitempty"`

	// Enveloped signature in [JSON Signature Format
	// (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
	Signature ServiceSignature `json:"signature,omitempty" yaml:"signature,omitempty" mapstructure:"signature,omitempty"`

	// The name of the trust zone the service resides in.
	TrustZone *string `json:"trustZone,omitempty" yaml:"trustZone,omitempty" mapstructure:"trustZone,omitempty"`

	// The service version.
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`

	// A boolean value indicating if use of the service crosses a trust zone or
	// boundary. A value of true indicates that by using the service, a trust boundary
	// is crossed. A value of false indicates that by using the service, a trust
	// boundary is not crossed.
	XTrustBoundary *bool `json:"x-trust-boundary,omitempty" yaml:"x-trust-boundary,omitempty" mapstructure:"x-trust-boundary,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Service) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in Service: required")
	}
	type Plain Service
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Service(plain)
	return nil
}

var enumValues_ComponentEvidenceIdentityMethodsElemTechnique = []interface{}{
	"source-code-analysis",
	"binary-analysis",
	"manifest-analysis",
	"ast-fingerprint",
	"hash-comparison",
	"instrumentation",
	"dynamic-analysis",
	"filename",
	"attestation",
	"other",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentEvidenceIdentityField) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ComponentEvidenceIdentityField {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ComponentEvidenceIdentityField, v)
	}
	*j = ComponentEvidenceIdentityField(v)
	return nil
}

var enumValues_ComponentEvidenceIdentityField = []interface{}{
	"group",
	"name",
	"version",
	"purl",
	"cpe",
	"swid",
	"hash",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Annotations) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["annotator"]; !ok || v == nil {
		return fmt.Errorf("field annotator in Annotations: required")
	}
	if v, ok := raw["subjects"]; !ok || v == nil {
		return fmt.Errorf("field subjects in Annotations: required")
	}
	if v, ok := raw["text"]; !ok || v == nil {
		return fmt.Errorf("field text in Annotations: required")
	}
	if v, ok := raw["timestamp"]; !ok || v == nil {
		return fmt.Errorf("field timestamp in Annotations: required")
	}
	type Plain Annotations
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Annotations(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Copyright) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["text"]; !ok || v == nil {
		return fmt.Errorf("field text in Copyright: required")
	}
	type Plain Copyright
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Copyright(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentEvidenceCallstackFramesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["module"]; !ok || v == nil {
		return fmt.Errorf("field module in ComponentEvidenceCallstackFramesElem: required")
	}
	type Plain ComponentEvidenceCallstackFramesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ComponentEvidenceCallstackFramesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in ComponentData: required")
	}
	type Plain ComponentData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ComponentData(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentDataType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ComponentDataType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ComponentDataType, v)
	}
	*j = ComponentDataType(v)
	return nil
}

var enumValues_ComponentDataType = []interface{}{
	"source-code",
	"configuration",
	"dataset",
	"definition",
	"other",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReleaseNotes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in ReleaseNotes: required")
	}
	type Plain ReleaseNotes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ReleaseNotes(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Compositions) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["aggregate"]; !ok || v == nil {
		return fmt.Errorf("field aggregate in Compositions: required")
	}
	type Plain Compositions
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Compositions(plain)
	return nil
}

type ReleaseNotes struct {
	// One or more alternate names the release may be referred to. This may include
	// unofficial terms used by development and marketing teams (e.g. code names).
	Aliases []string `json:"aliases,omitempty" yaml:"aliases,omitempty" mapstructure:"aliases,omitempty"`

	// A short description of the release.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The URL to an image that may be prominently displayed with the release note.
	FeaturedImage *string `json:"featuredImage,omitempty" yaml:"featuredImage,omitempty" mapstructure:"featuredImage,omitempty"`

	// Zero or more release notes containing the locale and content. Multiple note
	// objects may be specified to support release notes in a wide variety of
	// languages.
	Notes []Note `json:"notes,omitempty" yaml:"notes,omitempty" mapstructure:"notes,omitempty"`

	// Provides the ability to document properties in a name-value store. This
	// provides flexibility to include data not officially supported in the standard
	// without having to use additional namespaces or create extensions. Unlike
	// key-value stores, properties support duplicate names, each potentially having
	// different values. Property names of interest to the general public are
	// encouraged to be registered in the [CycloneDX Property
	// Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal
	// registration is OPTIONAL.
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// A collection of issues that have been resolved.
	Resolves []Issue `json:"resolves,omitempty" yaml:"resolves,omitempty" mapstructure:"resolves,omitempty"`

	// The URL to an image that may be used in messaging on social media platforms.
	SocialImage *string `json:"socialImage,omitempty" yaml:"socialImage,omitempty" mapstructure:"socialImage,omitempty"`

	// One or more tags that may aid in search or retrieval of the release note.
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// The date and time (timestamp) when the release note was created.
	Timestamp *time.Time `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// The title of the release.
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// The software versioning type the release note describes.
	Type ReleaseType `json:"type" yaml:"type" mapstructure:"type"`
}

type OrganizationalEntity struct {
	// An optional identifier which can be used to reference the object elsewhere in
	// the BOM. Every bom-ref MUST be unique within the BOM.
	BomRef *RefType `json:"bom-ref,omitempty" yaml:"bom-ref,omitempty" mapstructure:"bom-ref,omitempty"`

	// A contact at the organization. Multiple contacts are allowed.
	Contact []OrganizationalContact `json:"contact,omitempty" yaml:"contact,omitempty" mapstructure:"contact,omitempty"`

	// The name of the organization
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The URL of the organization. Multiple URLs are allowed.
	Url []string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

type OrganizationalContact struct {
	// An optional identifier which can be used to reference the object elsewhere in
	// the BOM. Every bom-ref MUST be unique within the BOM.
	BomRef *RefType `json:"bom-ref,omitempty" yaml:"bom-ref,omitempty" mapstructure:"bom-ref,omitempty"`

	// The email address of the contact.
	Email *string `json:"email,omitempty" yaml:"email,omitempty" mapstructure:"email,omitempty"`

	// The name of a contact
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The phone number of the contact.
	Phone *string `json:"phone,omitempty" yaml:"phone,omitempty" mapstructure:"phone,omitempty"`
}

// Provides the ability to document properties in a name-value store. This provides
// flexibility to include data not officially supported in the standard without
// having to use additional namespaces or create extensions. Unlike key-value
// stores, properties support duplicate names, each potentially having different
// values. Property names of interest to the general public are encouraged to be
// registered in the [CycloneDX Property
// Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal
// registration is OPTIONAL.
type Property struct {
	// The name of the property. Duplicate names are allowed, each potentially having
	// a different value.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The value of the property.
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Attachment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["content"]; !ok || v == nil {
		return fmt.Errorf("field content in Attachment: required")
	}
	type Plain Attachment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["contentType"]; !ok || v == nil {
		plain.ContentType = "text/plain"
	}
	*j = Attachment(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Dependency) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ref"]; !ok || v == nil {
		return fmt.Errorf("field ref in Dependency: required")
	}
	type Plain Dependency
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Dependency(plain)
	return nil
}

// A reference to a locally defined resource (e.g., a bom-ref) or an externally
// accessible resource.
type ResourceReferenceChoice struct {
	// Reference to an externally accessible resource.
	ExternalReference *ExternalReference `json:"externalReference,omitempty" yaml:"externalReference,omitempty" mapstructure:"externalReference,omitempty"`

	// References an object by its bom-ref attribute
	Ref interface{} `json:"ref,omitempty" yaml:"ref,omitempty" mapstructure:"ref,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AttachmentEncoding) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AttachmentEncoding {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AttachmentEncoding, v)
	}
	*j = AttachmentEncoding(v)
	return nil
}

// A representation of a functional parameter.
type Parameter struct {
	// The data type of the parameter.
	DataType *string `json:"dataType,omitempty" yaml:"dataType,omitempty" mapstructure:"dataType,omitempty"`

	// The name of the parameter.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The value of the parameter.
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

// The software versioning type. It is RECOMMENDED that the release type use one of
// 'major', 'minor', 'patch', 'pre-release', or 'internal'. Representing all
// possible software release types is not practical, so standardizing on the
// recommended values, whenever possible, is strongly encouraged.
//
// * __major__ = A major release may contain significant changes or may introduce
// breaking changes.
// * __minor__ = A minor release, also known as an update, may contain a smaller
// number of changes than major releases.
// * __patch__ = Patch releases are typically unplanned and may resolve defects or
// important security issues.
// * __pre-release__ = A pre-release may include alpha, beta, or release candidates
// and typically have limited support. They provide the ability to preview a
// release prior to its general availability.
// * __internal__ = Internal releases are not for public consumption and are
// intended to be used exclusively by the project or manufacturer that produced it.
type ReleaseType string

type OutputTypeType string

var enumValues_OutputTypeType = []interface{}{
	"artifact",
	"attestation",
	"log",
	"evidence",
	"metrics",
	"other",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OutputTypeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OutputTypeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OutputTypeType, v)
	}
	*j = OutputTypeType(v)
	return nil
}

const OutputTypeTypeArtifact OutputTypeType = "artifact"
const OutputTypeTypeAttestation OutputTypeType = "attestation"
const OutputTypeTypeLog OutputTypeType = "log"
const OutputTypeTypeEvidence OutputTypeType = "evidence"
const OutputTypeTypeMetrics OutputTypeType = "metrics"
const OutputTypeTypeOther OutputTypeType = "other"

type OutputType struct {
	// Outputs that have the form of data.
	Data *Attachment `json:"data,omitempty" yaml:"data,omitempty" mapstructure:"data,omitempty"`

	// Outputs that have the form of environment variables.
	EnvironmentVars []interface{} `json:"environmentVars,omitempty" yaml:"environmentVars,omitempty" mapstructure:"environmentVars,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// A reference to an independent resource generated as output by the task.
	Resource *ResourceReferenceChoice `json:"resource,omitempty" yaml:"resource,omitempty" mapstructure:"resource,omitempty"`

	// Component or service that generated or provided the output from the task (e.g.,
	// a build tool)
	Source *ResourceReferenceChoice `json:"source,omitempty" yaml:"source,omitempty" mapstructure:"source,omitempty"`

	// Component or service that received the output from the task (e.g., reference to
	// an artifactory service with data flow value of `outbound`)
	Target *ResourceReferenceChoice `json:"target,omitempty" yaml:"target,omitempty" mapstructure:"target,omitempty"`

	// Describes the type of data output.
	Type *OutputTypeType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// Executes specific commands or tools in order to accomplish its owning task as
// part of a sequence.
type Step struct {
	// Ordered list of commands or directives for the step
	Commands []Command `json:"commands,omitempty" yaml:"commands,omitempty" mapstructure:"commands,omitempty"`

	// A description of the step.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// A name for the step.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

type TaskType string

var enumValues_TaskType = []interface{}{
	"copy",
	"clone",
	"lint",
	"scan",
	"merge",
	"build",
	"test",
	"deliver",
	"deploy",
	"release",
	"clean",
	"other",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TaskType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TaskType, v)
	}
	*j = TaskType(v)
	return nil
}

const TaskTypeCopy TaskType = "copy"
const TaskTypeClone TaskType = "clone"
const TaskTypeLint TaskType = "lint"
const TaskTypeScan TaskType = "scan"
const TaskTypeMerge TaskType = "merge"
const TaskTypeBuild TaskType = "build"
const TaskTypeTest TaskType = "test"
const TaskTypeDeliver TaskType = "deliver"
const TaskTypeDeploy TaskType = "deploy"
const TaskTypeRelease TaskType = "release"
const TaskTypeClean TaskType = "clean"
const TaskTypeOther TaskType = "other"

type TriggerType string

var enumValues_TriggerType = []interface{}{
	"manual",
	"api",
	"webhook",
	"scheduled",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TriggerType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TriggerType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TriggerType, v)
	}
	*j = TriggerType(v)
	return nil
}

const TriggerTypeManual TriggerType = "manual"
const TriggerTypeApi TriggerType = "api"
const TriggerTypeWebhook TriggerType = "webhook"
const TriggerTypeScheduled TriggerType = "scheduled"

// Represents a resource that can conditionally activate (or fire) tasks based upon
// associated events and their data.
type Trigger struct {
	// An optional identifier which can be used to reference the trigger elsewhere in
	// the BOM. Every bom-ref MUST be unique within the BOM.
	BomRef RefType `json:"bom-ref" yaml:"bom-ref" mapstructure:"bom-ref"`

	// Conditions corresponds to the JSON schema field "conditions".
	Conditions []Condition `json:"conditions,omitempty" yaml:"conditions,omitempty" mapstructure:"conditions,omitempty"`

	// A description of the resource instance.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The event data that caused the associated trigger to activate.
	Event *Event `json:"event,omitempty" yaml:"event,omitempty" mapstructure:"event,omitempty"`

	// Represents resources and data brought into a task at runtime by executor or
	// task commands
	Inputs []InputType `json:"inputs,omitempty" yaml:"inputs,omitempty" mapstructure:"inputs,omitempty"`

	// The name of the resource instance.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Represents resources and data output from a task at runtime by executor or task
	// commands
	Outputs []OutputType `json:"outputs,omitempty" yaml:"outputs,omitempty" mapstructure:"outputs,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// References to component or service resources that are used to realize the
	// resource instance.
	ResourceReferences []ResourceReferenceChoice `json:"resourceReferences,omitempty" yaml:"resourceReferences,omitempty" mapstructure:"resourceReferences,omitempty"`

	// The date and time (timestamp) when the trigger was activated.
	TimeActivated *time.Time `json:"timeActivated,omitempty" yaml:"timeActivated,omitempty" mapstructure:"timeActivated,omitempty"`

	// The source type of event which caused the trigger to fire.
	Type TriggerType `json:"type" yaml:"type" mapstructure:"type"`

	// The unique identifier for the resource instance within its deployment context.
	Uid string `json:"uid" yaml:"uid" mapstructure:"uid"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Trigger) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["bom-ref"]; !ok || v == nil {
		return fmt.Errorf("field bom-ref in Trigger: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in Trigger: required")
	}
	if v, ok := raw["uid"]; !ok || v == nil {
		return fmt.Errorf("field uid in Trigger: required")
	}
	type Plain Trigger
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Trigger(plain)
	return nil
}

type WorkspaceAccessMode string

var enumValues_WorkspaceAccessMode = []interface{}{
	"read-only",
	"read-write",
	"read-write-once",
	"write-once",
	"write-only",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorkspaceAccessMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WorkspaceAccessMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WorkspaceAccessMode, v)
	}
	*j = WorkspaceAccessMode(v)
	return nil
}

const WorkspaceAccessModeReadOnly WorkspaceAccessMode = "read-only"
const WorkspaceAccessModeReadWrite WorkspaceAccessMode = "read-write"
const WorkspaceAccessModeReadWriteOnce WorkspaceAccessMode = "read-write-once"
const WorkspaceAccessModeWriteOnce WorkspaceAccessMode = "write-once"
const WorkspaceAccessModeWriteOnly WorkspaceAccessMode = "write-only"

type VolumeMode string

var enumValues_VolumeMode = []interface{}{
	"filesystem",
	"block",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VolumeMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VolumeMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VolumeMode, v)
	}
	*j = VolumeMode(v)
	return nil
}

const VolumeModeFilesystem VolumeMode = "filesystem"
const VolumeModeBlock VolumeMode = "block"

// An identifiable, logical unit of data storage tied to a physical device.
type Volume struct {
	// The mode for the volume instance.
	Mode VolumeMode `json:"mode,omitempty" yaml:"mode,omitempty" mapstructure:"mode,omitempty"`

	// The name of the volume instance
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The underlying path created from the actual volume.
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// Indicates if the volume persists beyond the life of the resource it is
	// associated with.
	Persistent *bool `json:"persistent,omitempty" yaml:"persistent,omitempty" mapstructure:"persistent,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// Indicates if the volume is remotely (i.e., network) attached.
	Remote *bool `json:"remote,omitempty" yaml:"remote,omitempty" mapstructure:"remote,omitempty"`

	// The allocated size of the volume accessible to the associated workspace. This
	// should include the scalar size as well as IEC standard unit in either decimal
	// or binary form.
	SizeAllocated *string `json:"sizeAllocated,omitempty" yaml:"sizeAllocated,omitempty" mapstructure:"sizeAllocated,omitempty"`

	// The unique identifier for the volume instance within its deployment context.
	Uid *string `json:"uid,omitempty" yaml:"uid,omitempty" mapstructure:"uid,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Volume) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Volume
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["mode"]; !ok || v == nil {
		plain.Mode = "filesystem"
	}
	*j = Volume(plain)
	return nil
}

// A named filesystem or data resource shareable by workflow tasks.
type Workspace struct {
	// Describes the read-write access control for the workspace relative to the
	// owning resource instance.
	AccessMode *WorkspaceAccessMode `json:"accessMode,omitempty" yaml:"accessMode,omitempty" mapstructure:"accessMode,omitempty"`

	// The names for the workspace as referenced by other workflow tasks. Effectively,
	// a name mapping so other tasks can use their own local name in their steps.
	Aliases []string `json:"aliases,omitempty" yaml:"aliases,omitempty" mapstructure:"aliases,omitempty"`

	// An optional identifier which can be used to reference the workspace elsewhere
	// in the BOM. Every bom-ref MUST be unique within the BOM.
	BomRef RefType `json:"bom-ref" yaml:"bom-ref" mapstructure:"bom-ref"`

	// A description of the resource instance.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The name of a domain-specific data type the workspace represents.
	ManagedDataType *string `json:"managedDataType,omitempty" yaml:"managedDataType,omitempty" mapstructure:"managedDataType,omitempty"`

	// A path to a location on disk where the workspace will be available to the
	// associated task's steps.
	MountPath *string `json:"mountPath,omitempty" yaml:"mountPath,omitempty" mapstructure:"mountPath,omitempty"`

	// The name of the resource instance.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// References to component or service resources that are used to realize the
	// resource instance.
	ResourceReferences []ResourceReferenceChoice `json:"resourceReferences,omitempty" yaml:"resourceReferences,omitempty" mapstructure:"resourceReferences,omitempty"`

	// The unique identifier for the resource instance within its deployment context.
	Uid string `json:"uid" yaml:"uid" mapstructure:"uid"`

	// Information about the actual volume instance allocated to the workspace.
	Volume *Volume `json:"volume,omitempty" yaml:"volume,omitempty" mapstructure:"volume,omitempty"`

	// Identifies the reference to the request for a specific volume type and
	// parameters.
	VolumeRequest *string `json:"volumeRequest,omitempty" yaml:"volumeRequest,omitempty" mapstructure:"volumeRequest,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Workspace) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["bom-ref"]; !ok || v == nil {
		return fmt.Errorf("field bom-ref in Workspace: required")
	}
	if v, ok := raw["uid"]; !ok || v == nil {
		return fmt.Errorf("field uid in Workspace: required")
	}
	type Plain Workspace
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Workspace(plain)
	return nil
}

// Describes the inputs, sequence of steps and resources used to accomplish a task
// and its output.
type Task struct {
	// An optional identifier which can be used to reference the task elsewhere in the
	// BOM. Every bom-ref MUST be unique within the BOM.
	BomRef RefType `json:"bom-ref" yaml:"bom-ref" mapstructure:"bom-ref"`

	// A description of the resource instance.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Represents resources and data brought into a task at runtime by executor or
	// task commands
	Inputs []InputType `json:"inputs,omitempty" yaml:"inputs,omitempty" mapstructure:"inputs,omitempty"`

	// The name of the resource instance.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Represents resources and data output from a task at runtime by executor or task
	// commands
	Outputs []OutputType `json:"outputs,omitempty" yaml:"outputs,omitempty" mapstructure:"outputs,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// References to component or service resources that are used to realize the
	// resource instance.
	ResourceReferences []ResourceReferenceChoice `json:"resourceReferences,omitempty" yaml:"resourceReferences,omitempty" mapstructure:"resourceReferences,omitempty"`

	// A graph of the component runtime topology for task's instance.
	RuntimeTopology []Dependency `json:"runtimeTopology,omitempty" yaml:"runtimeTopology,omitempty" mapstructure:"runtimeTopology,omitempty"`

	// The sequence of steps for the task.
	Steps []Step `json:"steps,omitempty" yaml:"steps,omitempty" mapstructure:"steps,omitempty"`

	// Indicates the types of activities performed by the set of workflow tasks.
	TaskTypes []TaskType `json:"taskTypes" yaml:"taskTypes" mapstructure:"taskTypes"`

	// The date and time (timestamp) when the task ended.
	TimeEnd *time.Time `json:"timeEnd,omitempty" yaml:"timeEnd,omitempty" mapstructure:"timeEnd,omitempty"`

	// The date and time (timestamp) when the task started.
	TimeStart *time.Time `json:"timeStart,omitempty" yaml:"timeStart,omitempty" mapstructure:"timeStart,omitempty"`

	// The trigger that initiated the task.
	Trigger *Trigger `json:"trigger,omitempty" yaml:"trigger,omitempty" mapstructure:"trigger,omitempty"`

	// The unique identifier for the resource instance within its deployment context.
	Uid string `json:"uid" yaml:"uid" mapstructure:"uid"`

	// A set of named filesystem or data resource shareable by workflow tasks.
	Workspaces []Workspace `json:"workspaces,omitempty" yaml:"workspaces,omitempty" mapstructure:"workspaces,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Task) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["bom-ref"]; !ok || v == nil {
		return fmt.Errorf("field bom-ref in Task: required")
	}
	if v, ok := raw["taskTypes"]; !ok || v == nil {
		return fmt.Errorf("field taskTypes in Task: required")
	}
	if v, ok := raw["uid"]; !ok || v == nil {
		return fmt.Errorf("field uid in Task: required")
	}
	type Plain Task
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Task(plain)
	return nil
}

// A specialized orchestration task.
type Workflow struct {
	// An optional identifier which can be used to reference the workflow elsewhere in
	// the BOM. Every bom-ref MUST be unique within the BOM.
	BomRef RefType `json:"bom-ref" yaml:"bom-ref" mapstructure:"bom-ref"`

	// A description of the resource instance.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Represents resources and data brought into a task at runtime by executor or
	// task commands
	Inputs []InputType `json:"inputs,omitempty" yaml:"inputs,omitempty" mapstructure:"inputs,omitempty"`

	// The name of the resource instance.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Represents resources and data output from a task at runtime by executor or task
	// commands
	Outputs []OutputType `json:"outputs,omitempty" yaml:"outputs,omitempty" mapstructure:"outputs,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// References to component or service resources that are used to realize the
	// resource instance.
	ResourceReferences []ResourceReferenceChoice `json:"resourceReferences,omitempty" yaml:"resourceReferences,omitempty" mapstructure:"resourceReferences,omitempty"`

	// A graph of the component runtime topology for workflow's instance.
	RuntimeTopology []Dependency `json:"runtimeTopology,omitempty" yaml:"runtimeTopology,omitempty" mapstructure:"runtimeTopology,omitempty"`

	// The sequence of steps for the task.
	Steps []Step `json:"steps,omitempty" yaml:"steps,omitempty" mapstructure:"steps,omitempty"`

	// The graph of dependencies between tasks within the workflow.
	TaskDependencies []Dependency `json:"taskDependencies,omitempty" yaml:"taskDependencies,omitempty" mapstructure:"taskDependencies,omitempty"`

	// Indicates the types of activities performed by the set of workflow tasks.
	TaskTypes []TaskType `json:"taskTypes" yaml:"taskTypes" mapstructure:"taskTypes"`

	// The tasks that comprise the workflow.
	Tasks []Task `json:"tasks,omitempty" yaml:"tasks,omitempty" mapstructure:"tasks,omitempty"`

	// The date and time (timestamp) when the task ended.
	TimeEnd *time.Time `json:"timeEnd,omitempty" yaml:"timeEnd,omitempty" mapstructure:"timeEnd,omitempty"`

	// The date and time (timestamp) when the task started.
	TimeStart *time.Time `json:"timeStart,omitempty" yaml:"timeStart,omitempty" mapstructure:"timeStart,omitempty"`

	// The trigger that initiated the task.
	Trigger *Trigger `json:"trigger,omitempty" yaml:"trigger,omitempty" mapstructure:"trigger,omitempty"`

	// The unique identifier for the resource instance within its deployment context.
	Uid string `json:"uid" yaml:"uid" mapstructure:"uid"`

	// A set of named filesystem or data resource shareable by workflow tasks.
	Workspaces []Workspace `json:"workspaces,omitempty" yaml:"workspaces,omitempty" mapstructure:"workspaces,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Workflow) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["bom-ref"]; !ok || v == nil {
		return fmt.Errorf("field bom-ref in Workflow: required")
	}
	if v, ok := raw["taskTypes"]; !ok || v == nil {
		return fmt.Errorf("field taskTypes in Workflow: required")
	}
	if v, ok := raw["uid"]; !ok || v == nil {
		return fmt.Errorf("field uid in Workflow: required")
	}
	type Plain Workflow
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Workflow(plain)
	return nil
}

var enumValues_AttachmentEncoding = []interface{}{
	"base64",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ComponentType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ComponentType, v)
	}
	*j = ComponentType(v)
	return nil
}

var enumValues_ImpactAnalysisJustification = []interface{}{
	"code_not_present",
	"code_not_reachable",
	"requires_configuration",
	"requires_dependency",
	"requires_environment",
	"protected_by_compiler",
	"protected_at_runtime",
	"protected_at_perimeter",
	"protected_by_mitigating_control",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImpactAnalysisJustification) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ImpactAnalysisJustification {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ImpactAnalysisJustification, v)
	}
	*j = ImpactAnalysisJustification(v)
	return nil
}

// A note containing the locale and content.
type Note struct {
	// The ISO-639 (or higher) language code and optional ISO-3166 (or higher) country
	// code. Examples include: "en", "en-US", "fr" and "fr-CA"
	Locale *LocaleType `json:"locale,omitempty" yaml:"locale,omitempty" mapstructure:"locale,omitempty"`

	// Specifies the full content of the release note.
	Text Attachment `json:"text" yaml:"text" mapstructure:"text"`
}

// Defines a syntax for representing two character language code (ISO-639) followed
// by an optional two character country code. The language code MUST be lower case.
// If the country code is specified, the country code MUST be upper case. The
// language code and country code MUST be separated by a minus sign. Examples: en,
// en-US, fr, fr-CA
type LocaleType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExternalReferenceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExternalReferenceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExternalReferenceType, v)
	}
	*j = ExternalReferenceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Patch) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in Patch: required")
	}
	type Plain Patch
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Patch(plain)
	return nil
}

// Specifies an individual patch
type Patch struct {
	// The patch file (or diff) that show changes. Refer to
	// [https://en.wikipedia.org/wiki/Diff](https://en.wikipedia.org/wiki/Diff)
	Diff *Diff `json:"diff,omitempty" yaml:"diff,omitempty" mapstructure:"diff,omitempty"`

	// A collection of issues the patch resolves
	Resolves []Issue `json:"resolves,omitempty" yaml:"resolves,omitempty" mapstructure:"resolves,omitempty"`

	// Specifies the purpose for the patch including the resolution of defects,
	// security issues, or new behavior or functionality.
	//
	// * __unofficial__ = A patch which is not developed by the creators or
	// maintainers of the software being patched. Refer to
	// [https://en.wikipedia.org/wiki/Unofficial_patch](https://en.wikipedia.org/wiki/Unofficial_patch)
	// * __monkey__ = A patch which dynamically modifies runtime behavior. Refer to
	// [https://en.wikipedia.org/wiki/Monkey_patch](https://en.wikipedia.org/wiki/Monkey_patch)
	// * __backport__ = A patch which takes code from a newer version of software and
	// applies it to older versions of the same software. Refer to
	// [https://en.wikipedia.org/wiki/Backporting](https://en.wikipedia.org/wiki/Backporting)
	// * __cherry-pick__ = A patch created by selectively applying commits from other
	// versions or branches of the same software.
	Type PatchType `json:"type" yaml:"type" mapstructure:"type"`
}

const PatchTypeCherryPick PatchType = "cherry-pick"
const PatchTypeBackport PatchType = "backport"
const PatchTypeMonkey PatchType = "monkey"
const PatchTypeUnofficial PatchType = "unofficial"

// UnmarshalJSON implements json.Unmarshaler.
func (j *PatchType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PatchType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PatchType, v)
	}
	*j = PatchType(v)
	return nil
}

var enumValues_ImpactAnalysisState = []interface{}{
	"resolved",
	"resolved_with_pedigree",
	"exploitable",
	"in_triage",
	"false_positive",
	"not_affected",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImpactAnalysisState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ImpactAnalysisState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ImpactAnalysisState, v)
	}
	*j = ImpactAnalysisState(v)
	return nil
}

var enumValues_PatchType = []interface{}{
	"unofficial",
	"monkey",
	"backport",
	"cherry-pick",
}

type PatchType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Issue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in Issue: required")
	}
	type Plain Issue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Issue(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IssueType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IssueType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IssueType, v)
	}
	*j = IssueType(v)
	return nil
}

var enumValues_IssueType = []interface{}{
	"defect",
	"enhancement",
	"security",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExternalReference) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in ExternalReference: required")
	}
	if v, ok := raw["url"]; !ok || v == nil {
		return fmt.Errorf("field url in ExternalReference: required")
	}
	type Plain ExternalReference
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ExternalReference(plain)
	return nil
}

type Risk struct {
	// Strategy used to address this risk.
	MitigationStrategy *string `json:"mitigationStrategy,omitempty" yaml:"mitigationStrategy,omitempty" mapstructure:"mitigationStrategy,omitempty"`

	// The name of the risk.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

var enumValues_LicenseLicensingLicenseTypesElem = []interface{}{
	"academic",
	"appliance",
	"client-access",
	"concurrent-user",
	"core-points",
	"custom-metric",
	"device",
	"evaluation",
	"named-user",
	"node-locked",
	"oem",
	"perpetual",
	"processor-points",
	"subscription",
	"user",
	"other",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LicenseLicensingLicenseTypesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LicenseLicensingLicenseTypesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LicenseLicensingLicenseTypesElem, v)
	}
	*j = LicenseLicensingLicenseTypesElem(v)
	return nil
}

// A model card describes the intended uses of a machine learning model and
// potential limitations, including biases and ethical considerations. Model cards
// typically contain the training parameters, which datasets were used to train the
// model, performance metrics, and other relevant data useful for ML transparency.
// This object SHOULD be specified for any component of type
// `machine-learning-model` and MUST NOT be specified for other component types.
type ModelCard struct {
	// An optional identifier which can be used to reference the model card elsewhere
	// in the BOM. Every bom-ref MUST be unique within the BOM.
	BomRef *RefType `json:"bom-ref,omitempty" yaml:"bom-ref,omitempty" mapstructure:"bom-ref,omitempty"`

	// What considerations should be taken into account regarding the model's
	// construction, training, and application?
	Considerations *ModelCardConsiderations `json:"considerations,omitempty" yaml:"considerations,omitempty" mapstructure:"considerations,omitempty"`

	// Hyper-parameters for construction of the model.
	ModelParameters *ModelCardModelParameters `json:"modelParameters,omitempty" yaml:"modelParameters,omitempty" mapstructure:"modelParameters,omitempty"`

	// Provides the ability to document properties in a name-value store. This
	// provides flexibility to include data not officially supported in the standard
	// without having to use additional namespaces or create extensions. Unlike
	// key-value stores, properties support duplicate names, each potentially having
	// different values. Property names of interest to the general public are
	// encouraged to be registered in the [CycloneDX Property
	// Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal
	// registration is OPTIONAL.
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// A quantitative analysis of the model
	QuantitativeAnalysis *ModelCardQuantitativeAnalysis `json:"quantitativeAnalysis,omitempty" yaml:"quantitativeAnalysis,omitempty" mapstructure:"quantitativeAnalysis,omitempty"`
}

// A quantitative analysis of the model
type ModelCardQuantitativeAnalysis struct {
	// Graphics corresponds to the JSON schema field "graphics".
	Graphics *GraphicsCollection `json:"graphics,omitempty" yaml:"graphics,omitempty" mapstructure:"graphics,omitempty"`

	// The model performance metrics being reported. Examples may include accuracy, F1
	// score, precision, top-3 error rates, MSC, etc.
	PerformanceMetrics []PerformanceMetric `json:"performanceMetrics,omitempty" yaml:"performanceMetrics,omitempty" mapstructure:"performanceMetrics,omitempty"`
}

type PerformanceMetric struct {
	// The confidence interval of the metric.
	ConfidenceInterval *PerformanceMetricConfidenceInterval `json:"confidenceInterval,omitempty" yaml:"confidenceInterval,omitempty" mapstructure:"confidenceInterval,omitempty"`

	// The name of the slice this metric was computed on. By default, assume this
	// metric is not sliced.
	Slice *string `json:"slice,omitempty" yaml:"slice,omitempty" mapstructure:"slice,omitempty"`

	// The type of performance metric.
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// The value of the performance metric.
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

// The confidence interval of the metric.
type PerformanceMetricConfidenceInterval struct {
	// The lower bound of the confidence interval.
	LowerBound *string `json:"lowerBound,omitempty" yaml:"lowerBound,omitempty" mapstructure:"lowerBound,omitempty"`

	// The upper bound of the confidence interval.
	UpperBound *string `json:"upperBound,omitempty" yaml:"upperBound,omitempty" mapstructure:"upperBound,omitempty"`
}

// Hyper-parameters for construction of the model.
type ModelCardModelParameters struct {
	// The overall approach to learning used by the model for problem solving.
	Approach *ModelCardModelParametersApproach `json:"approach,omitempty" yaml:"approach,omitempty" mapstructure:"approach,omitempty"`

	// The model architecture family such as transformer network, convolutional neural
	// network, residual neural network, LSTM neural network, etc.
	ArchitectureFamily *string `json:"architectureFamily,omitempty" yaml:"architectureFamily,omitempty" mapstructure:"architectureFamily,omitempty"`

	// The datasets used to train and evaluate the model.
	Datasets []interface{} `json:"datasets,omitempty" yaml:"datasets,omitempty" mapstructure:"datasets,omitempty"`

	// The input format(s) of the model
	Inputs []InputOutputMLParameters `json:"inputs,omitempty" yaml:"inputs,omitempty" mapstructure:"inputs,omitempty"`

	// The specific architecture of the model such as GPT-1, ResNet-50, YOLOv3, etc.
	ModelArchitecture *string `json:"modelArchitecture,omitempty" yaml:"modelArchitecture,omitempty" mapstructure:"modelArchitecture,omitempty"`

	// The output format(s) from the model
	Outputs []InputOutputMLParameters `json:"outputs,omitempty" yaml:"outputs,omitempty" mapstructure:"outputs,omitempty"`

	// Directly influences the input and/or output. Examples include classification,
	// regression, clustering, etc.
	Task *string `json:"task,omitempty" yaml:"task,omitempty" mapstructure:"task,omitempty"`
}

// The overall approach to learning used by the model for problem solving.
type ModelCardModelParametersApproach struct {
	// Learning types describing the learning problem or hybrid learning problem.
	Type *ModelCardModelParametersApproachType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

const ModelCardModelParametersApproachTypeSelfSupervised ModelCardModelParametersApproachType = "self-supervised"
const ModelCardModelParametersApproachTypeSemiSupervised ModelCardModelParametersApproachType = "semi-supervised"
const ModelCardModelParametersApproachTypeReinforcementLearning ModelCardModelParametersApproachType = "reinforcement-learning"
const ModelCardModelParametersApproachTypeUnsupervised ModelCardModelParametersApproachType = "unsupervised"
const ModelCardModelParametersApproachTypeSupervised ModelCardModelParametersApproachType = "supervised"

// What considerations should be taken into account regarding the model's
// construction, training, and application?
type ModelCardConsiderations struct {
	// What are the ethical (or environmental) risks involved in the application of
	// this model?
	EthicalConsiderations []Risk `json:"ethicalConsiderations,omitempty" yaml:"ethicalConsiderations,omitempty" mapstructure:"ethicalConsiderations,omitempty"`

	// How does the model affect groups at risk of being systematically disadvantaged?
	// What are the harms and benefits to the various affected groups?
	FairnessAssessments []FairnessAssessment `json:"fairnessAssessments,omitempty" yaml:"fairnessAssessments,omitempty" mapstructure:"fairnessAssessments,omitempty"`

	// What are the known tradeoffs in accuracy/performance of the model?
	PerformanceTradeoffs []string `json:"performanceTradeoffs,omitempty" yaml:"performanceTradeoffs,omitempty" mapstructure:"performanceTradeoffs,omitempty"`

	// What are the known technical limitations of the model? E.g. What kind(s) of
	// data should the model be expected not to perform well on? What are the factors
	// that might degrade model performance?
	TechnicalLimitations []string `json:"technicalLimitations,omitempty" yaml:"technicalLimitations,omitempty" mapstructure:"technicalLimitations,omitempty"`

	// What are the intended use cases of the model?
	UseCases []string `json:"useCases,omitempty" yaml:"useCases,omitempty" mapstructure:"useCases,omitempty"`

	// Who are the intended users of the model?
	Users []string `json:"users,omitempty" yaml:"users,omitempty" mapstructure:"users,omitempty"`
}

const LicenseLicensingLicenseTypesElemProcessorPoints LicenseLicensingLicenseTypesElem = "processor-points"
const LicenseLicensingLicenseTypesElemSubscription LicenseLicensingLicenseTypesElem = "subscription"
const LicenseLicensingLicenseTypesElemUser LicenseLicensingLicenseTypesElem = "user"

// UnmarshalJSON implements json.Unmarshaler.
func (j *ModelCardModelParametersApproachType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ModelCardModelParametersApproachType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ModelCardModelParametersApproachType, v)
	}
	*j = ModelCardModelParametersApproachType(v)
	return nil
}

// The individual or organization for which a license was granted to
type LicenseLicensingLicensee struct {
	// The individual, not associated with an organization, that was granted the
	// license
	Individual *OrganizationalContact `json:"individual,omitempty" yaml:"individual,omitempty" mapstructure:"individual,omitempty"`

	// The organization that was granted the license
	Organization *OrganizationalEntity `json:"organization,omitempty" yaml:"organization,omitempty" mapstructure:"organization,omitempty"`
}

// The individual or organization that grants a license to another individual or
// organization
type LicenseLicensingLicensor struct {
	// The individual, not associated with an organization, that granted the license
	Individual *OrganizationalContact `json:"individual,omitempty" yaml:"individual,omitempty" mapstructure:"individual,omitempty"`

	// The organization that granted the license
	Organization *OrganizationalEntity `json:"organization,omitempty" yaml:"organization,omitempty" mapstructure:"organization,omitempty"`
}

// The individual or organization that purchased the license
type LicenseLicensingPurchaser struct {
	// The individual, not associated with an organization, that purchased the license
	Individual *OrganizationalContact `json:"individual,omitempty" yaml:"individual,omitempty" mapstructure:"individual,omitempty"`

	// The organization that purchased the license
	Organization *OrganizationalEntity `json:"organization,omitempty" yaml:"organization,omitempty" mapstructure:"organization,omitempty"`
}

var enumValues_ModelCardModelParametersApproachType = []interface{}{
	"supervised",
	"unsupervised",
	"reinforcement-learning",
	"semi-supervised",
	"self-supervised",
}

type ModelCardModelParametersApproachType string

// The product lifecycle(s) that this BOM represents.
type MetadataLifecyclesElem map[string]interface{}

type Metadata struct {
	// The person(s) who created the BOM. Authors are common in BOMs created through
	// manual processes. BOMs created through automated means may not have authors.
	Authors []OrganizationalContact `json:"authors,omitempty" yaml:"authors,omitempty" mapstructure:"authors,omitempty"`

	// The component that the BOM describes.
	Component *Component `json:"component,omitempty" yaml:"component,omitempty" mapstructure:"component,omitempty"`

	// Licenses corresponds to the JSON schema field "licenses".
	Licenses LicenseChoice `json:"licenses,omitempty" yaml:"licenses,omitempty" mapstructure:"licenses,omitempty"`

	// Lifecycles corresponds to the JSON schema field "lifecycles".
	Lifecycles []MetadataLifecyclesElem `json:"lifecycles,omitempty" yaml:"lifecycles,omitempty" mapstructure:"lifecycles,omitempty"`

	// The organization that manufactured the component that the BOM describes.
	Manufacture *OrganizationalEntity `json:"manufacture,omitempty" yaml:"manufacture,omitempty" mapstructure:"manufacture,omitempty"`

	// Provides the ability to document properties in a name-value store. This
	// provides flexibility to include data not officially supported in the standard
	// without having to use additional namespaces or create extensions. Unlike
	// key-value stores, properties support duplicate names, each potentially having
	// different values. Property names of interest to the general public are
	// encouraged to be registered in the [CycloneDX Property
	// Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal
	// registration is OPTIONAL.
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	//  The organization that supplied the component that the BOM describes. The
	// supplier may often be the manufacturer, but may also be a distributor or
	// repackager.
	Supplier *OrganizationalEntity `json:"supplier,omitempty" yaml:"supplier,omitempty" mapstructure:"supplier,omitempty"`

	// The date and time (timestamp) when the BOM was created.
	Timestamp *time.Time `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Tools corresponds to the JSON schema field "tools".
	Tools interface{} `json:"tools,omitempty" yaml:"tools,omitempty" mapstructure:"tools,omitempty"`
}

// A version range specified in Package URL Version Range syntax (vers) which is
// defined at https://github.com/package-url/purl-spec/VERSION-RANGE-SPEC.rst
type Range string

type ScoreMethod string

var enumValues_ScoreMethod = []interface{}{
	"CVSSv2",
	"CVSSv3",
	"CVSSv31",
	"CVSSv4",
	"OWASP",
	"SSVC",
	"other",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ScoreMethod) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ScoreMethod {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ScoreMethod, v)
	}
	*j = ScoreMethod(v)
	return nil
}

const ScoreMethodCVSSv2 ScoreMethod = "CVSSv2"
const ScoreMethodCVSSv3 ScoreMethod = "CVSSv3"
const ScoreMethodCVSSv31 ScoreMethod = "CVSSv31"
const ScoreMethodCVSSv4 ScoreMethod = "CVSSv4"
const ScoreMethodOWASP ScoreMethod = "OWASP"
const ScoreMethodSSVC ScoreMethod = "SSVC"
const ScoreMethodOther ScoreMethod = "other"


var enumValues_Severity = []interface{}{
	"critical",
	"high",
	"medium",
	"low",
	"info",
	"none",
	"unknown",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Severity) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Severity {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Severity, v)
	}
	*j = Severity(v)
	return nil
}


// The source of vulnerability information. This is often the organization that
// published the vulnerability.
type VulnerabilitySource struct {
	// The name of the source.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The url of the vulnerability documentation as provided by the source.
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

// Defines the severity or risk ratings of a vulnerability.
type Rating struct {
	// An optional reason for rating the vulnerability as it was
	Justification *string `json:"justification,omitempty" yaml:"justification,omitempty" mapstructure:"justification,omitempty"`

	// Method corresponds to the JSON schema field "method".
	Method *ScoreMethod `json:"method,omitempty" yaml:"method,omitempty" mapstructure:"method,omitempty"`

	// The numerical score of the rating.
	Score *float64 `json:"score,omitempty" yaml:"score,omitempty" mapstructure:"score,omitempty"`

	// Textual representation of the severity that corresponds to the numerical score
	// of the rating.
	Severity *Severity `json:"severity,omitempty" yaml:"severity,omitempty" mapstructure:"severity,omitempty"`

	// The source that calculated the severity or risk rating of the vulnerability.
	Source *VulnerabilitySource `json:"source,omitempty" yaml:"source,omitempty" mapstructure:"source,omitempty"`

	// Textual representation of the metric values used to score the vulnerability
	Vector *string `json:"vector,omitempty" yaml:"vector,omitempty" mapstructure:"vector,omitempty"`
}

// Descriptor for an element identified by the attribute 'bom-ref' in the same BOM
// document.
// In contrast to `bomLinkElementType`.
type RefLinkType interface{}

// [Deprecated] - DO NOT USE. This will be removed in a future version. This will
// be removed in a future version. Use component or service instead. Information
// about the automated or manual tool used
type Tool struct {
	// External references provide a way to document systems, sites, and information
	// that may be relevant, but are not included with the BOM. They may also
	// establish specific relationships within or external to the BOM.
	ExternalReferences []ExternalReference `json:"externalReferences,omitempty" yaml:"externalReferences,omitempty" mapstructure:"externalReferences,omitempty"`

	// The hashes of the tool (if applicable).
	Hashes []Hash `json:"hashes,omitempty" yaml:"hashes,omitempty" mapstructure:"hashes,omitempty"`

	// The name of the tool
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The name of the vendor who created the tool
	Vendor *string `json:"vendor,omitempty" yaml:"vendor,omitempty" mapstructure:"vendor,omitempty"`

	// The version of the tool
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

// A single version of a component or service.
type Version string

type VulnerabilityAffectsElemVersionsElem struct {
	// A version range specified in Package URL Version Range syntax (vers) which is
	// defined at https://github.com/package-url/purl-spec/VERSION-RANGE-SPEC.rst
	Range *Range `json:"range,omitempty" yaml:"range,omitempty" mapstructure:"range,omitempty"`

	// The vulnerability status for the version or range of versions.
	Status AffectedStatus `json:"status,omitempty" yaml:"status,omitempty" mapstructure:"status,omitempty"`

	// A single version of a component or service.
	Version *Version `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VulnerabilityAffectsElemVersionsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain VulnerabilityAffectsElemVersionsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["status"]; !ok || v == nil {
		plain.Status = "affected"
	}
	*j = VulnerabilityAffectsElemVersionsElem(plain)
	return nil
}

type VulnerabilityAffectsElem struct {
	// References a component or service by the objects bom-ref
	Ref interface{} `json:"ref" yaml:"ref" mapstructure:"ref"`

	// Zero or more individual versions or range of versions.
	Versions []VulnerabilityAffectsElemVersionsElem `json:"versions,omitempty" yaml:"versions,omitempty" mapstructure:"versions,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VulnerabilityAffectsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ref"]; !ok || v == nil {
		return fmt.Errorf("field ref in VulnerabilityAffectsElem: required")
	}
	type Plain VulnerabilityAffectsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VulnerabilityAffectsElem(plain)
	return nil
}

type VulnerabilityAnalysisResponseElem string

var enumValues_VulnerabilityAnalysisResponseElem = []interface{}{
	"can_not_fix",
	"will_not_fix",
	"update",
	"rollback",
	"workaround_available",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VulnerabilityAnalysisResponseElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VulnerabilityAnalysisResponseElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VulnerabilityAnalysisResponseElem, v)
	}
	*j = VulnerabilityAnalysisResponseElem(v)
	return nil
}

const VulnerabilityAnalysisResponseElemCanNotFix VulnerabilityAnalysisResponseElem = "can_not_fix"
const VulnerabilityAnalysisResponseElemWillNotFix VulnerabilityAnalysisResponseElem = "will_not_fix"
const VulnerabilityAnalysisResponseElemUpdate VulnerabilityAnalysisResponseElem = "update"
const VulnerabilityAnalysisResponseElemRollback VulnerabilityAnalysisResponseElem = "rollback"
const VulnerabilityAnalysisResponseElemWorkaroundAvailable VulnerabilityAnalysisResponseElem = "workaround_available"

// An assessment of the impact and exploitability of the vulnerability.
type VulnerabilityAnalysis struct {
	// Detailed description of the impact including methods used during assessment. If
	// a vulnerability is not exploitable, this field should include specific details
	// on why the component or service is not impacted by this vulnerability.
	Detail *string `json:"detail,omitempty" yaml:"detail,omitempty" mapstructure:"detail,omitempty"`

	// The date and time (timestamp) when the analysis was first issued.
	FirstIssued *time.Time `json:"firstIssued,omitempty" yaml:"firstIssued,omitempty" mapstructure:"firstIssued,omitempty"`

	// Justification corresponds to the JSON schema field "justification".
	Justification *ImpactAnalysisJustification `json:"justification,omitempty" yaml:"justification,omitempty" mapstructure:"justification,omitempty"`

	// The date and time (timestamp) when the analysis was last updated.
	LastUpdated *time.Time `json:"lastUpdated,omitempty" yaml:"lastUpdated,omitempty" mapstructure:"lastUpdated,omitempty"`

	// A response to the vulnerability by the manufacturer, supplier, or project
	// responsible for the affected component or service. More than one response is
	// allowed. Responses are strongly encouraged for vulnerabilities where the
	// analysis state is exploitable.
	Response []VulnerabilityAnalysisResponseElem `json:"response,omitempty" yaml:"response,omitempty" mapstructure:"response,omitempty"`

	// State corresponds to the JSON schema field "state".
	State *ImpactAnalysisState `json:"state,omitempty" yaml:"state,omitempty" mapstructure:"state,omitempty"`
}

// Individuals or organizations credited with the discovery of the vulnerability.
type VulnerabilityCredits struct {
	// The individuals, not associated with organizations, that are credited with
	// vulnerability discovery.
	Individuals []OrganizationalContact `json:"individuals,omitempty" yaml:"individuals,omitempty" mapstructure:"individuals,omitempty"`

	// The organizations credited with vulnerability discovery.
	Organizations []OrganizationalEntity `json:"organizations,omitempty" yaml:"organizations,omitempty" mapstructure:"organizations,omitempty"`
}

// Evidence used to reproduce the vulnerability.
type VulnerabilityProofOfConcept struct {
	// A description of the environment in which reproduction was possible.
	Environment *string `json:"environment,omitempty" yaml:"environment,omitempty" mapstructure:"environment,omitempty"`

	// Precise steps to reproduce the vulnerability.
	ReproductionSteps *string `json:"reproductionSteps,omitempty" yaml:"reproductionSteps,omitempty" mapstructure:"reproductionSteps,omitempty"`

	// Supporting material that helps in reproducing or understanding how reproduction
	// is possible. This may include screenshots, payloads, and PoC exploit code.
	SupportingMaterial []Attachment `json:"supportingMaterial,omitempty" yaml:"supportingMaterial,omitempty" mapstructure:"supportingMaterial,omitempty"`
}

type VulnerabilityReferencesElem struct {
	// An identifier that uniquely identifies the vulnerability.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The source that published the vulnerability.
	Source VulnerabilitySource `json:"source" yaml:"source" mapstructure:"source"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VulnerabilityReferencesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in VulnerabilityReferencesElem: required")
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source in VulnerabilityReferencesElem: required")
	}
	type Plain VulnerabilityReferencesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VulnerabilityReferencesElem(plain)
	return nil
}

// Defines a weakness in a component or service that could be exploited or
// triggered by a threat source.
type Vulnerability struct {
	// Published advisories of the vulnerability if provided.
	Advisories []Advisory `json:"advisories,omitempty" yaml:"advisories,omitempty" mapstructure:"advisories,omitempty"`

	// The components or services that are affected by the vulnerability.
	Affects []VulnerabilityAffectsElem `json:"affects,omitempty" yaml:"affects,omitempty" mapstructure:"affects,omitempty"`

	// An assessment of the impact and exploitability of the vulnerability.
	Analysis *VulnerabilityAnalysis `json:"analysis,omitempty" yaml:"analysis,omitempty" mapstructure:"analysis,omitempty"`

	// An optional identifier which can be used to reference the vulnerability
	// elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.
	BomRef *RefType `json:"bom-ref,omitempty" yaml:"bom-ref,omitempty" mapstructure:"bom-ref,omitempty"`

	// The date and time (timestamp) when the vulnerability record was created in the
	// vulnerability database.
	Created *time.Time `json:"created,omitempty" yaml:"created,omitempty" mapstructure:"created,omitempty"`

	// Individuals or organizations credited with the discovery of the vulnerability.
	Credits *VulnerabilityCredits `json:"credits,omitempty" yaml:"credits,omitempty" mapstructure:"credits,omitempty"`

	// List of Common Weaknesses Enumerations (CWEs) codes that describes this
	// vulnerability. For example 399 (of
	// https://cwe.mitre.org/data/definitions/399.html)
	Cwes []Cwe `json:"cwes,omitempty" yaml:"cwes,omitempty" mapstructure:"cwes,omitempty"`

	// A description of the vulnerability as provided by the source.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// If available, an in-depth description of the vulnerability as provided by the
	// source organization. Details often include information useful in understanding
	// root cause.
	Detail *string `json:"detail,omitempty" yaml:"detail,omitempty" mapstructure:"detail,omitempty"`

	// The identifier that uniquely identifies the vulnerability.
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Evidence used to reproduce the vulnerability.
	ProofOfConcept *VulnerabilityProofOfConcept `json:"proofOfConcept,omitempty" yaml:"proofOfConcept,omitempty" mapstructure:"proofOfConcept,omitempty"`

	// Provides the ability to document properties in a name-value store. This
	// provides flexibility to include data not officially supported in the standard
	// without having to use additional namespaces or create extensions. Unlike
	// key-value stores, properties support duplicate names, each potentially having
	// different values. Property names of interest to the general public are
	// encouraged to be registered in the [CycloneDX Property
	// Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal
	// registration is OPTIONAL.
	Properties []Property `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The date and time (timestamp) when the vulnerability record was first
	// published.
	Published *time.Time `json:"published,omitempty" yaml:"published,omitempty" mapstructure:"published,omitempty"`

	// List of vulnerability ratings
	Ratings []Rating `json:"ratings,omitempty" yaml:"ratings,omitempty" mapstructure:"ratings,omitempty"`

	// Recommendations of how the vulnerability can be remediated or mitigated.
	Recommendation *string `json:"recommendation,omitempty" yaml:"recommendation,omitempty" mapstructure:"recommendation,omitempty"`

	// Zero or more pointers to vulnerabilities that are the equivalent of the
	// vulnerability specified. Often times, the same vulnerability may exist in
	// multiple sources of vulnerability intelligence, but have different identifiers.
	// References provide a way to correlate vulnerabilities across multiple sources
	// of vulnerability intelligence.
	References []VulnerabilityReferencesElem `json:"references,omitempty" yaml:"references,omitempty" mapstructure:"references,omitempty"`

	// The date and time (timestamp) when the vulnerability record was rejected (if
	// applicable).
	Rejected *time.Time `json:"rejected,omitempty" yaml:"rejected,omitempty" mapstructure:"rejected,omitempty"`

	// The source that published the vulnerability.
	Source *VulnerabilitySource `json:"source,omitempty" yaml:"source,omitempty" mapstructure:"source,omitempty"`

	// Tools corresponds to the JSON schema field "tools".
	Tools interface{} `json:"tools,omitempty" yaml:"tools,omitempty" mapstructure:"tools,omitempty"`

	// The date and time (timestamp) when the vulnerability record was last updated.
	Updated *time.Time `json:"updated,omitempty" yaml:"updated,omitempty" mapstructure:"updated,omitempty"`

	// A bypass, usually temporary, of the vulnerability that reduces its likelihood
	// and/or impact. Workarounds often involve changes to configuration or
	// deployments.
	Workaround *string `json:"workaround,omitempty" yaml:"workaround,omitempty" mapstructure:"workaround,omitempty"`
}

// Identifier for referable and therefore interlink-able elements.
type RefType string

var enumValues_CycloneDxSchema = []interface{}{
	"http://cyclonedx.org/schema/bom-1.5.schema.json",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CycloneDxSchema) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CycloneDxSchema {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CycloneDxSchema, v)
	}
	*j = CycloneDxSchema(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AggregateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AggregateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AggregateType, v)
	}
	*j = AggregateType(v)
	return nil
}

var enumValues_AggregateType = []interface{}{
	"complete",
	"incomplete",
	"incomplete_first_party_only",
	"incomplete_first_party_proprietary_only",
	"incomplete_first_party_opensource_only",
	"incomplete_third_party_only",
	"incomplete_third_party_proprietary_only",
	"incomplete_third_party_opensource_only",
	"unknown",
	"not_specified",
}
var enumValues_CycloneDxBomFormat = []interface{}{
	"CycloneDX",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CycloneDxBomFormat) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CycloneDxBomFormat {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CycloneDxBomFormat, v)
	}
	*j = CycloneDxBomFormat(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AffectedStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AffectedStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AffectedStatus, v)
	}
	*j = AffectedStatus(v)
	return nil
}

var enumValues_AffectedStatus = []interface{}{
	"affected",
	"unaffected",
	"unknown",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Advisory) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["url"]; !ok || v == nil {
		return fmt.Errorf("field url in Advisory: required")
	}
	type Plain Advisory
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Advisory(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CycloneDx) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["bomFormat"]; !ok || v == nil {
		return fmt.Errorf("field bomFormat in CycloneDx: required")
	}
	if v, ok := raw["specVersion"]; !ok || v == nil {
		return fmt.Errorf("field specVersion in CycloneDx: required")
	}
	type Plain CycloneDx
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["version"]; !ok || v == nil {
		plain.Version = 1.0
	}
	*j = CycloneDx(plain)
	return nil
}
